{
	"information_for_contributors": [
		"This file has been converted from https://github.com/PowerShell/EditorSyntax/blob/master/PowerShellSyntax.tmLanguage",
		"If you want to provide a fix or improvement, please create a pull request against the original repository.",
		"Once accepted there, we are happy to receive an update request."
	],
	"version": "altered from https://github.com/PowerShell/EditorSyntax/commit/472c9447da4e3160bef211d5e1a0c2dee3cce497",
	"name": "PowerShell",
	"scopeName": "source.powershell",
	"patterns": [
		{
			"include": "#scriptblock"
		},
		{
			"include": "#type"
		},
		{
			"begin": "(?i:class)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.other.class.powershell"
				}
			},
			"end": "}|(?=[^\\s])",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.braces.end.powershell"
				}
			},
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "[\\p{L}_]\\w*",
					"beginCaptures": {
						"0": {
							"name": "entity.name.type.class.powershell"
						}
					},
					"end": "(?=[^\\s])",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": ":",
							"beginCaptures": {
								"0": {
									"name": "punctuation.separator.colon.powershell"
								}
							},
							"end": "(?=[^\\s:])",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
									"beginCaptures": {
										"0": {
											"patterns": [
												{
													"include": "#type_keywords"
												},
												{
													"match": "[^\\.]+",
													"name": "entity.other.inherited-class.powershell"
												},
												{
													"match": "\\.",
													"name": "punctuation.accessor.type.powershell"
												}
											]
										}
									},
									"end": "(?=[^\\s])",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": ",",
											"beginCaptures": {
												"0": {
													"name": "punctuation.separator.comma.powershell"
												}
											},
											"end": "(?=[^\\s:])",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
													"beginCaptures": {
														"0": {
															"patterns": [
																{
																	"include": "#type_keywords"
																},
																{
																	"match": "[^\\.]+",
																	"name": "entity.other.inherited-class.powershell"
																},
																{
																	"match": "\\.",
																	"name": "punctuation.accessor.type.powershell"
																}
															]
														}
													},
													"end": "(?=[^\\s])",
													"applyEndPatternLast": true,
													"patterns": [
														{
															"include": "#notCode"
														}
													]
												},
												{
													"include": "#notCode"
												}
											]
										},
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "(?=})",
					"contentName": "meta.class.powershell",
					"patterns": [
						{
							"match": "((?i:hidden|static))(?=\\s)",
							"name": "storage.modifier.powershell"
						},
						{
							"begin": "(?=[\\p{L}_])",
							"end": "}|(?=[^\\s])|$(?=\\n)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"applyEndPatternLast": true,
							"name": "meta.method.powershell",
							"patterns": [
								{
									"match": "`\\n",
									"name": "constant.character.escape.powershell"
								},
								{
									"begin": "\\G([\\p{L}_]\\w*)",
									"beginCaptures": {
										"1": {
											"name": "entity.name.function.powershell"
										}
									},
									"end": "(?=[^\\s])|$(?=\\n)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": "(?=\\()",
											"end": "(?=[^\\s])",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": ":",
													"beginCaptures": {
														"0": {
															"name": "punctuation.separator.colon.powershell"
														}
													},
													"end": "(?=[;{])",
													"patterns": [
														{
															"begin": "(?i:base)(?![^\\s{(,;&|)}])",
															"beginCaptures": {
																"0": {
																	"name": "variable.language.super.powershell"
																}
															},
															"end": "(?=[;{])",
															"patterns": [
																{
																	"include": "#declarationParameterSet"
																}
															]
														}
													]
												},
												{
													"include": "#declarationParameterSet"
												},
												{
													"begin": "{",
													"beginCaptures": {
														"0": {
															"name": "punctuation.section.braces.begin.powershell"
														}
													},
													"end": "(?=})",
													"contentName": "meta.method-body.powershell",
													"patterns": [
														{
															"include": "$self"
														}
													]
												},
												{
													"include": "#notCode"
												}
											]
										},
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "$self"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "((?i:enum))(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"1": {
					"name": "keyword.other.enum.powershell"
				}
			},
			"end": "(?=[^\\s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "([\\p{L}_]\\w*)",
					"beginCaptures": {
						"1": {
							"name": "entity.name.type.enum.powershell"
						}
					},
					"end": "(?=[^\\s])|(?<=})",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"comment": "optional user specified type, PowerShell Core >= 6.2.0",
							"begin": ":",
							"beginCaptures": {
								"0": {
									"name": "punctuation.separator.colon.powershell"
								}
							},
							"end": "(?=[^\\s:])|(?<=})",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
									"beginCaptures": {
										"0": {
											"patterns": [
												{
													"include": "#type_keywords"
												},
												{
													"match": "[^\\.]+",
													"name": "storage.type.powershell"
												},
												{
													"match": "\\.",
													"name": "punctuation.accessor.type.powershell"
												}
											]
										}
									},
									"end": "(?=[^\\s])|(?<=})",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.enumeration.powershell",
					"patterns": [
						{
							"match": ";",
							"name": "punctuation.terminator.statement.powershell"
						},
						{
							"begin": "([\\p{L}_]\\w*)",
							"beginCaptures": {
								"1": {
									"name": "entity.name.variable.enum-member.powershell"
								}
							},
							"end": "(?<=;)|(?=[}\\n])",
							"patterns": [
								{
									"begin": "=",
									"beginCaptures": {
										"0": {
											"name": "keyword.operator.assignment.enum-member.powershell"
										}
									},
									"end": "(?<=;)|(?=[}\\n])",
									"patterns": [
										{
											"comment": "!!this needs rewritten as it cannot test for a preunary operator until after the first token has been located!!  This logic needs updated in multiple locations",
											"include": "#operators_preUnary"
										},
										{
											"comment": "after testing for pre unary operators, after anything has matched, stay locked in expression mode.",
											"begin": "(?!\\G)(?!$(?=\\n)|(?=[;|)}\\]]))",
											"end": "$(?=\\n)|(?=[;|)}\\]])",
											"patterns": [
												{
													"include": "#expression_mode"
												}
											]
										},
										{
											"include": "#expression_mode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:function|filter|workflow)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.other.$0.powershell"
				}
			},
			"end": "(?=[//s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(?:(global|local|script|private)(`)?(:)(?=[^\\s{(,;&|)}])|(?=[^`\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}\\s{(,;&|)}<>@#\\]]|`(?!\\s)))",
					"beginCaptures": {
						"1": {
							"name": "storage.modifier.scope.powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					},
					"end": "(?=[//s])|(?<=})",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G",
							"end": "(?=[\\s{(,;&|)}])",
							"name": "entity.name.function.powershell",
							"patterns": [
								{
									"comment": "function names that start with `:` are treated differently",
									"match": "\\G(?<!:):\\p{L}\\w*[^\\s{(,;&|)}]?"
								},
								{
									"include": "#functionName"
								}
							]
						},
						{
							"begin": "(?<!\\G)(?<!})",
							"end": "(?=[//s])|(?<=})",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "{",
									"beginCaptures": {
										"0": {
											"name": "punctuation.section.braces.begin.powershell"
										}
									},
									"end": "}",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.braces.end.powershell"
										}
									},
									"name": "meta.function.powershell",
									"patterns": [
										{
											"include": "$self"
										}
									]
								},
								{
									"include": "#declarationParameterSet"
								},
								{
									"include": "#notCode"
								}
							]
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "do,for,foreach,while: allow a `:label` that must start the statement; A `:label` before a loop looks just like a function, and its possible to put the loop keyword on a later line!  Here we just see if a valid label appears to be the only useful thing on a single line",
			"match": "(?>(:)([\\p{L}_]\\w*)(?![^\\s{(,;&|)}]))(?=(?>(?:`\\s|\\s*<#.*?#>)*)\\s*(?:(?i:do|for(?:each)?|while)(?![^\\s{(,;&|)}])|#|<#.*$|`?$))",
			"captures": {
				"1": {
					"name": "punctuation.separator.colon.label.powershell"
				},
				"2": {
					"name": "entity.name.label.powershell"
				},
				"3": {
					"patterns": [
						{
							"include": "#commentBlock"
						}
					]
				}
			}
		},
		{
			"comment": "break,continue: permit a label following, then revert back to statement mode",
			"begin": "(?i:break|continue)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.$0.powershell"
				}
			},
			"end": "[\\p{L}_]\\w*|(?=$\\n|\\S)",
			"endCaptures": {
				"0": {
					"name": "entity.name.label.powershell"
				}
			},
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#commentBlock"
				}
			]
		},
		{
			"begin": "(?i:return)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.$0.powershell"
				}
			},
			"end": "$(?=\\n)|(?=[;|)}\\]])",
			"patterns": [
				{
					"include": "#command_mode"
				}
			]
		},
		{
			"begin": "(?i:foreach)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.foreach.powershell"
				}
			},
			"end": "(?=[^\\s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.foreach-set.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"begin": "(?i:in)",
							"beginCaptures": {
								"0": {
									"name": "keyword.control.foreach-in.powershell"
								}
							},
							"end": "(?=[;)])",
							"patterns": [
								{
									"comment": "`;` not permitted here",
									"match": ";",
									"name": "invalid.terminator.statement.powershell"
								},
								{
									"include": "#command_mode"
								}
							]
						},
						{
							"include": "#variableNoProperty"
						},
						{
							"include": "#type"
						},
						{
							"comment": "`;` not permitted here",
							"match": ";",
							"name": "invalid.terminator.statement.powershell"
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.foreach-statements.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"comment": "-parallel parameter can only be used in a workflow, consider using meta scopes, and an injection to properly catch this",
					"match": "(?i:[\\x{2013}-\\x{2015}-]parallel)",
					"name": "entity.name.parameter.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:while)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.while.powershell"
				}
			},
			"end": "(?=[^\\s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.while-condition.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"comment": "`;` not permitted here",
							"match": ";",
							"name": "invalid.terminator.statement.powershell"
						},
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.while-statements.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:for)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.for.powershell"
				}
			},
			"end": "(?=[^\\s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.for-condition.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.for-statements.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"match": "(?i:do)(?![^\\s{(,;&|)}])",
			"name": "keyword.control.$0.powershell"
		},
		{
			"begin": "(?i:switch)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.switch.powershell"
				}
			},
			"end": "(?=[^\\s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.switch-value.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"comment": "`;` not permitted here",
							"match": ";",
							"name": "invalid.terminator.statement.powershell"
						},
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.switch-conditions.powershell",
					"patterns": [
						{
							"comment": "default: only in switch",
							"match": "(?i:default)(?![^\\s{(,;&|)}])",
							"name": "keyword.control.$0.powershell"
						},
						{
							"include": "$self"
						}
					]
				},
				{
					"comment": "only allow switch arguments before the `(` or `{`",
					"begin": "\\G(?=[\\s#\\x{2013}-\\x{2015}-]|<#)",
					"end": "(?=[^\\s#\\x{2013}-\\x{2015}-]|<#)",
					"patterns": [
						{
							"match": "(?i:[\\x{2013}-\\x{2015}-](regex|wildcard|exact|casesensitive))",
							"name": "entity.name.parameter.powershell"
						},
						{
							"comment": "-file is special case, needs file argument, no condition expression",
							"begin": "(?i:[\\x{2013}-\\x{2015}-]file)",
							"beginCaptures": {
								"0": {
									"name": "entity.name.parameter.powershell"
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\G(?![{(;&|)}])",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#argument"
										},
										{
											"include": "#advanceToToken"
										}
									]
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"match": "(?i:(using))\\s+(?i:(namespace|module))\\s+(?i:((?:\\w+(?:\\.)?)+))",
			"captures": {
				"1": {
					"name": "keyword.control.using.powershell"
				},
				"2": {
					"name": "keyword.other.powershell"
				},
				"3": {
					"name": "variable.parameter.powershell"
				}
			}
		},
		{
			"comment": "from,var,define are reserved; configuration is TODO, needs significant syntax structure work.",
			"match": "(?i:configuration|define|from|var)(?![^\\s{(,;&|)}])",
			"name": "invalid.reserved.keyword.control.$0.powershell"
		},
		{
			"comment": "else,elsif: only after if,elseif; until: only after do; catch,finally: only after try; parallel,sequence,inlinescript only in a workflow",
			"match": "(?i:begin|catch|data|dynamicparam|else|elseif|end|exit|finally|if|inlinescript|parallel|param|process|sequence|throw|trap|try|until)(?![^\\s{(,;&|)}])",
			"name": "keyword.control.$0.powershell"
		},
		{
			"include": "#command_mode"
		}
	],
	"repository": {
		"command_mode": {
			"patterns": [
				{
					"comment": "`||` and `&&` conditional terminators are reserved.",
					"match": "\\|\\||&&",
					"name": "invalid.reserved.powershell"
				},
				{
					"comment": "`;` resume's in statement mode.",
					"match": ";",
					"name": "punctuation.terminator.statement.powershell"
				},
				{
					"comment": "(dot) source operator, requires trailing space, or invoke operator",
					"begin": "&|\\.(?=\\*?[\\s,;&|{}\\(\\)]|\\$[\\p{L}$?^:_{])",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.invoke-or-source.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;|)}\\]])",
					"patterns": [
						{
							"comment": "Next token needs to be an operand for the operator, not the actual command, but an expression or unquoted expandable string that describes the command's name.",
							"include": "#argument_mode"
						}
					]
				},
				{
					"comment": "could be a numeric constant or a limited list of unary operators, that we should switch to expression mode",
					"begin": "(?=[\\d.!+\\x{2013}-\\x{2015}-])",
					"end": "$(?=\\n)|(?=[;|)}\\]])",
					"patterns": [
						{
							"include": "#operators_preUnary"
						},
						{
							"comment": "if unary operators/numeric constant advanced, switch to expression mode",
							"begin": "(?!\\G)(?!$(?=\\n)|(?=[;|)}\\]]))|\\G(?=[^\\d.!+\\x{2013}-\\x{2015}-]|$)",
							"end": "$(?=\\n)|(?=[;|)}\\]])",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						},
						{
							"comment": "if numeric constant didn't advanced, try finishing command mode with a command name",
							"begin": "\\G(?!$(?=\\n)|(?=[;|)}\\]]))",
							"end": "$(?=\\n)|(?=[;|)}\\]])",
							"patterns": [
								{
									"include": "#command_name"
								}
							]
						}
					]
				},
				{
					"comment": "patterns that indicate an expression, might be able to simplify this to include expression_mode and then see if the cursor advanced, sorta, don't forget about 'notCode'",
					"begin": "(?=\\$[{(\\w:$?^]|@?[({]|(?>@(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]))[^~`!@#$%^*<>\\]\\\\/\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}+\\x{2013}-\\x{2015}-]|[,\\[\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}])|(?=@?(['\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}])(?:(?<!@\\g<1>)|\\s*$))|(?=[\\x{2013}-\\x{2015}-][\\s#{(,;|)}<>.!+%*/=\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}\\x{2013}-\\x{2015}-])",
					"end": "$(?=\\n)|(?=[;|)}\\]])",
					"patterns": [
						{
							"include": "#expression_mode"
						}
					]
				},
				{
					"comment": "`|` resume's in command mode",
					"begin": "\\|",
					"beginCaptures": {
						"0": {
							"name": "punctuation.separator.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;&|)}\\]])",
					"patterns": [
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"include": "#command_name"
				}
			]
		},
		"command_name": {
			"patterns": [
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				},
				{
					"include": "#commands"
				},
				{
					"begin": "(?:(global|local|script|private)(`)?(:)(?=[^\\s{(,;&|)}])|(?=[^`\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}\\s{(,;&|)}<>@#\\]]|`(?!\\s)))",
					"beginCaptures": {
						"1": {
							"name": "storage.modifier.scope.powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					},
					"end": "(?!\\G)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G(?=[^\\n{(,;&|)}])",
							"end": "(?=[\\s{(,;&|)}])",
							"name": "variable.function.powershell",
							"patterns": [
								{
									"comment": "function names that start with `:` are treated differently",
									"match": "\\G(?<!:):\\p{L}\\w*[^\\s{(,;&|)}]?"
								},
								{
									"include": "#functionName"
								}
							]
						},
						{
							"begin": "(?![\\n;&|)}\\]])",
							"end": "$(?=\\n)|(?=[;|)}\\]])",
							"patterns": [
								{
									"include": "#argument_mode"
								}
							]
						}
					]
				}
			]
		},
		"argument": {
			"patterns": [
				{
					"include": "#scriptblock"
				},
				{
					"include": "#expressionGroup"
				},
				{
					"include": "#substatement"
				},
				{
					"include": "#hashtable"
				},
				{
					"include": "#array"
				},
				{
					"include": "#variable"
				},
				{
					"include": "#quotedStrings_Members"
				},
				{
					"begin": "(?=\\d)",
					"end": "(?!\\G)",
					"patterns": [
						{
							"include": "#numericConstant_argumentMode"
						},
						{
							"include": "#unquotedArgument"
						}
					]
				},
				{
					"include": "#unquotedArgument"
				}
			]
		},
		"argument_mode": {
			"patterns": [
				{
					"include": "#redirection"
				},
				{
					"include": "#jobOperator"
				},
				{
					"comment": "`,` just continues current mode",
					"match": ",",
					"name": "punctuation.separator.powershell"
				},
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				},
				{
					"begin": "(?<!\\w)(--%)(?!\\w)",
					"beginCaptures": {
						"1": {
							"name": "keyword.control.powershell"
						}
					},
					"end": "$|(?=\\|)",
					"patterns": [
						{
							"match": "[^\"\\x{201C}-\\x{201E}]+?",
							"name": "string.unquoted.powershell"
						},
						{
							"begin": "(?:[\"\\x{201C}-\\x{201E}])",
							"beginCaptures": {
								"0": {
									"name": "punctuation.definition.string.begin.powershell"
								}
							},
							"end": "(?:[\"\\x{201C}-\\x{201E}])|$",
							"applyEndPatternLast": true,
							"endCaptures": {
								"0": {
									"name": "punctuation.definition.string.end.powershell"
								}
							},
							"name": "string.quoted.double.powershell"
						}
					]
				},
				{
					"match": "([\\x{2013}-\\x{2015}-]\\p{L}\\w*)(:)?",
					"captures": {
						"1": {
							"name": "entity.name.parameter.powershell"
						},
						"2": {
							"name": "punctuation.separator.parameter-value.powershell"
						}
					}
				},
				{
					"include": "#argument"
				}
			]
		},
		"unquotedArgument": {
			"begin": "(?=[^\\s{(,;&|)}])",
			"alternateBegin": "(?=[^\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}\\s\\[(){},;&|$@])|(?<=\\S)(?=[$@<>])",
			"end": "(?=[\\s{(,;&|)}])",
			"contentName": "string.unquoted.argument.powershell",
			"patterns": [
				{
					"match": "\\G`[\\x{2013}-\\x{2015}-]",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unquotedStrings_text"
				}
			]
		},
		"expression_mode": {
			"patterns": [
				{
					"include": "#redirection"
				},
				{
					"comment": "`,` just continues current mode",
					"match": ",",
					"name": "punctuation.separator.powershell"
				},
				{
					"include": "#type"
				},
				{
					"include": "#operand"
				},
				{
					"include": "#operators"
				},
				{
					"include": "#notCode"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"operand": {
			"patterns": [
				{
					"include": "#variable"
				},
				{
					"include": "#expressionGroup"
				},
				{
					"include": "#hashtable"
				},
				{
					"include": "#scriptblock"
				},
				{
					"include": "#numericConstant"
				},
				{
					"include": "#array"
				},
				{
					"include": "#substatement"
				},
				{
					"include": "#quotedStrings_Members"
				}
			]
		},
		"array": {
			"begin": "(?=@\\()",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\G(@)(\\()",
					"beginCaptures": {
						"1": {
							"name": "keyword.other.array.begin.powershell"
						},
						"2": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"name": "meta.group.array-expression.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"commentBlock": {
			"begin": "<#",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.comment.block.begin.powershell"
				}
			},
			"end": "#>",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.comment.block.end.powershell"
				}
			},
			"name": "comment.block.powershell",
			"patterns": [
				{
					"include": "#commentEmbeddedDocs"
				}
			]
		},
		"commentLine": {
			"begin": "(#)#*",
			"captures": {
				"1": {
					"name": "punctuation.definition.comment.powershell"
				}
			},
			"end": "$(?=(\\n)?)",
			"ignore-endCaptures": {
				"1": {
					"name": "comment.line.powershell"
				}
			},
			"name": "comment.line.powershell",
			"patterns": [
				{
					"include": "#commentEmbeddedDocs"
				},
				{
					"include": "#RequiresDirective"
				}
			]
		},
		"argumentModeEscapes": {
			"patterns": [
				{
					"match": "`(?:[`0abefnrtv\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}$@#<>(){},;&|\\n])",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"attribute": {
			"begin": "(?i)(?:(?:cmdletbinding|alias|flags|outputtype|parameter|validate(?:not(?:null(?:orempty)?)|count|set|script|range|pattern|length)|allow(?:null|empty(?:collection|string))|supportswildcards|dsc(?:resource|property))(?=\\())|ordered(?![.\\w`])",
			"beginCaptures": {
				"0": {
					"name": "support.function.attribute.powershell"
				}
			},
			"end": "(?!\\G\\()",
			"name": "meta.attribute.powershell",
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"comment": "`key` for DscProperty attribute",
							"begin": "(?i)\\b(mandatory|valuefrom(?:pipeline(?:bypropertyname)?|remainingarguments)|position(?:albinding)?|(?:default)?parametersetname|supports(?:shouldprocess|paging|transactions)|help(?:uri|message)|confirmimpact|ignorecase|key)\\b",
							"beginCaptures": {
								"1": {
									"name": "variable.parameter.attribute.powershell"
								},
								"2": {
									"name": "keyword.operator.assignment.powershell"
								}
							},
							"end": "$(?=\\n)|(?=[,;&|)}\\]])",
							"patterns": [
								{
									"begin": "=",
									"beginCaptures": {
										"0": {
											"name": "keyword.operator.assignment.powershell"
										}
									},
									"end": "$(?=\\n)|(?=[,;&|)}\\]])",
									"patterns": [
										{
											"include": "#expression_mode"
										}
									]
								}
							]
						},
						{
							"include": "#expression_mode"
						}
					]
				}
			]
		},
		"commands": {
			"patterns": [
				{
					"comment": "Verb-Noun pattern:",
					"begin": "(?i:Add|Approve|Assert|Backup|Block|Build|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Deploy|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Mount|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Write)-(?:`.|[^\\s{(,;&|)}])+?(?:\\.(?i:exe|cmd|bat|ps1))?(?=[\\s{(,;&|)}])",
					"beginCaptures": {
						"0": {
							"name": "support.function.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;&|)}\\]])",
					"patterns": [
						{
							"include": "#argument_mode"
						}
					]
				},
				{
					"comment": "Builtin cmdlets with reserved verbs, trailing negative lookahead needs work",
					"begin": "(?i:(?:foreach|where|sort|tee)-object)(?=[\\s{(,;&|)}])",
					"beginCaptures": {
						"0": {
							"name": "support.function.$0.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;&|)}\\]])",
					"patterns": [
						{
							"include": "#argument_mode"
						}
					]
				}
			]
		},
		"commentEmbeddedDocs": {
			"patterns": [
				{
					"captures": {
						"1": {
							"name": "constant.string.documentation.powershell"
						},
						"2": {
							"name": "keyword.operator.documentation.powershell"
						}
					},
					"match": "(?:^|\\G)(?i:\\s*(\\.)(COMPONENT|DESCRIPTION|EXAMPLE|EXTERNALHELP|FORWARDHELP(?:CATEGORY|TARGETNAME)|FUNCTIONALITY|INPUTS|LINK|NOTES|OUTPUTS|REMOTEHELPRUNSPACE|ROLE|SYNOPSIS))(?:\\s*$)",
					"name": "comment.documentation.embedded.powershell"
				},
				{
					"captures": {
						"1": {
							"name": "constant.string.documentation.powershell"
						},
						"2": {
							"name": "keyword.operator.documentation.powershell"
						},
						"3": {
							"name": "keyword.operator.documentation.powershell"
						}
					},
					"match": "(?:^|\\G)(?i:\\s*(\\.)(PARAMETER|FORWARDHELP(?:CATEGORY|TARGETNAME)|REMOTEHELPRUNSPACE|EXTERNALHELP)\\s+([\\w-]+))",
					"name": "comment.documentation.embedded.powershell"
				}
			]
		},
		"unicodeEscape": {
			"comment": "`u{xxxx} added in PowerShell 6.0",
			"patterns": [
				{
					"match": "`u\\{(?:(?:10)?([0-9a-fA-F]){,4}|0?\\g<1>{1,5})}",
					"name": "constant.character.escape.powershell"
				},
				{
					"match": "`u(?:\\{[0-9a-fA-F]{,6}.)?",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"doubleQuotedStringEscapes": {
			"patterns": [
				{
					"match": "`(?:[`0abefnrtv\"\\x{201C}-\\x{201E}$])",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				},
				{
					"match": "(?:[\"\\x{201C}-\\x{201E}]){2}",
					"name": "constant.character.escape.powershell"
				}
			]
		},
		"doubleQuotedHereStringEscapes": {
			"patterns": [
				{
					"match": "`(?:[`0abefnrtv\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}$])",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"declarationParameterSet": {
			"begin": "\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.group.begin.powershell"
				}
			},
			"name": "meta.parameters.powershell",
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.group.end.powershell"
				}
			},
			"patterns": [
				{
					"begin": "=",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.assignment.parameter-default.powershell"
						}
					},
					"end": "(?<=,)|(?=[)\\n])",
					"patterns": [
						{
							"include": "#operators_preUnary"
						},
						{
							"comment": "after testing for pre unary operators, after anything has matched, stay locked in expression mode.",
							"begin": "(?!\\G)(?!$(?=\\n)|(?=[;|)}\\]]))",
							"end": "$(?=\\n)|(?=[;|)}\\]])",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						},
						{
							"include": "#expression_mode"
						}
					]
				},
				{
					"match": ",",
					"name": "punctuation.separator.comma.powershell"
				},
				{
					"include": "#variableNoProperty"
				},
				{
					"include": "#type"
				},
				{
					"include": "#notCode"
				}
			]
		},
		"expressionGroup": {
			"begin": "(?=\\()",
			"end": "(?!.\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.group.subexpression.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"substatement": {
			"begin": "(?=\\$\\()",
			"end": "(?!.\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(\\$)(\\()",
					"beginCaptures": {
						"1": {
							"name": "keyword.other.substatement.powershell"
						},
						"2": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.group.substatement-expression.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"substatementNoProperty": {
			"begin": "(\\$)(\\()",
			"beginCaptures": {
				"1": {
					"name": "keyword.other.substatement.powershell"
				},
				"2": {
					"name": "punctuation.section.group.begin.powershell"
				}
			},
			"name": "meta.embedded.substatement.powershell",
			"contentName": "interpolated.complex.source.powershell",
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.group.end.powershell"
				}
			},
			"patterns": [
				{
					"include": "$self"
				}
			]
		},
		"numericConstant": {
			"patterns": [
				{
					"beginCaptures": {
						"1": {
							"name": "constant.numeric.integer.powershell"
						},
						"3": {
							"name": "constant.language.powershell"
						}
					},
					"begin": "(?>([+\\x{2013}-\\x{2015}-]?(?:[0-9]+(?i:(?![ed]|\\.(?!\\.))l?|(?:\\.[0-9]*)?((?:(?i:e)[+\\x{2013}-\\x{2015}-]?[0-9]+)?l))|(?:\\.[0-9]+)\\g<2>))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}<>.!+%*/=\\x{2013}-\\x{2015}-])",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G(?=\\.(?!\\.)|::|\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						},
						{
							"begin": "\\G(?=[\\s#.+\\x{2013}-\\x{2015}-]|<#)(?![\\x{2013}-\\x{2015}-]\\p{L})",
							"end": "\\.\\.|\\+\\+?|([\\x{2013}-\\x{2015}-])(?!\\p{L})\\g<1>?|$|(?![\\s#]|<#)",
							"endCaptures":{
								"0":{
									"patterns":[
										{
											"include": "#operators"
										}
									]
								}
							},
							"patterns": [
								{
									"include": "#commentBlock"
								},
								{
									"include": "#commentLine"
								}
							]
						}
					]
				},
				{
					"beginCaptures": {
						"1": {
							"name": "constant.numeric.hex.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"begin": "(?>([+\\x{2013}-\\x{2015}-]?0(?i:x[0-9a-f_]+l?))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}<>.!+%*/=\\x{2013}-\\x{2015}-])",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G(?=\\.(?!\\.)|::|\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						},
						{
							"begin": "\\G(?=[\\s#.+\\x{2013}-\\x{2015}-]|<#)(?![\\x{2013}-\\x{2015}-]\\p{L})",
							"end": "\\.\\.|\\+\\+?|([\\x{2013}-\\x{2015}-])(?!\\p{L})\\g<1>?|$|(?![\\s#]|<#)",
							"endCaptures":{
								"0":{
									"patterns":[
										{
											"include": "#operators"
										}
									]
								}
							},
							"patterns": [
								{
									"include": "#commentBlock"
								},
								{
									"include": "#commentLine"
								}
							]
						}
					]
				},
				{
					"beginCaptures": {
						"1": {
							"name": "constant.numeric.decimal.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"begin": "(?>([+\\x{2013}-\\x{2015}-]?(?:(?:[0-9]+)|(?=\\.[0-9]))(?:\\.[0-9]*)?(?i:(?:e[+\\x{2013}-\\x{2015}-]?[0-9]+)?(?!l)d?))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}\\]<>.!+%*/=\\x{2013}-\\x{2015}-])",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G(?=\\.(?!\\.)|::|\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						},
						{
							"begin": "\\G(?=[\\s#.+\\x{2013}-\\x{2015}-]|<#)(?![\\x{2013}-\\x{2015}-]\\p{L})",
							"end": "\\.\\.|\\+\\+?|([\\x{2013}-\\x{2015}-])(?!\\p{L})\\g<1>?|$|(?![\\s#]|<#)",
							"endCaptures":{
								"0":{
									"patterns":[
										{
											"include": "#operators"
										}
									]
								}
							},
							"patterns": [
								{
									"include": "#commentBlock"
								},
								{
									"include": "#commentLine"
								}
							]
						}
					]
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.binary.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"comment": "(?>(?:(?<!\\w)|\\G)([+\\x{2013}-\\x{2015}-]?0(?i:b[01_]+l?))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}<>.!+%*/=\\x{2013}-\\x{2015}-])"
				}
			]
		},
		"numericConstant_argumentMode": {
			"patterns": [
				{
					"captures": {
						"1": {
							"name": "constant.numeric.integer.powershell"
						},
						"3": {
							"name": "constant.language.powershell"
						}
					},
					"match": "(?>((?:[0-9]+(?i:(?![ed]|\\.(?!\\.))l?|(?:\\.[0-9]*)?((?:(?i:e)[+\\x{2013}-\\x{2015}-]?[0-9]+)?l))|(?:\\.[0-9]+)\\g<2>)))((?i:[kmgtp]b)?)(?![^\\s{(,;|)}])"
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.hex.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"match": "(?>(0(?i:x[0-9a-f_]+l?))((?i:[kmgtp]b)?))(?![^\\s{(,;|)}])"
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.decimal.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"match": "(?>((?:(?:[0-9]+)|(?=\\.[0-9]))(?:\\.[0-9]*)?(?i:(?:e[+\\x{2013}-\\x{2015}-]?[0-9]+)?(?!l)d?))((?i:[kmgtp]b)?))(?![^\\s{(,;|)}])"
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.binary.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"comment": "(?>(?:(?<!\\w)|\\G)([+\\x{2013}-\\x{2015}-]?0(?i:b[01_]+l?))((?i:[kmgtp]b)?))(?![^\\s{(,;|)}])"
				}
			]
		},
		"scriptblock": {
			"begin": "(?={)",
			"end": "(?!.\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.scriptblock.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"type": {
			"comment": "This is used by both type and attribute references.",
			"begin": "(?=\\[)",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\[",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.bracket.begin.powershell"
						}
					},
					"end": "]",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.bracket.end.powershell"
						}
					},
					"applyEndPatternLast": true,
					"name": "meta.attribute-or-type-reference.powershell",
					"patterns": [
						{
							"match": "(?i:ref)(?=\\])",
							"name": "storage.modifier.powershell"
						},
						{
							"include": "#attribute"
						},
						{
							"include": "#type_SubType"
						},
						{
							"comment": "[^\\s\\W]+"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.bracket.end.powershell"
						}
					},
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						},
						{
							"begin": "(?!\\G)(?!$(?=\\n)|(?=[;|)}\\]]))",
							"end": "$(?=\\n)|(?=[;|)}\\]])",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						}
					]
				}
			]
		},
		"type_SubType": {
			"patterns": [
				{
					"begin": "(\\[)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.bracket.begin.powershell"
						}
					},
					"end": "(])|(?>[^\\s\\p{L},])",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.bracket.end.powershell"
						}
					},
					"applyEndPatternLast": true,
					"name": "meta.type-reference.powershell",
					"patterns": [
						{
							"include": "#type_SubType"
						},
						{
							"match": "(?<!])[^\\s\\[\\]+]+"
						}
					]
				},
				{
					"begin": "((?<![\\w-])([\\p{L}_]\\w*(?:\\.\\g<2>?)?)(?:`+\\d+)?(?:\\++\\g<1>)?)",
					"beginCaptures": {
						"0": {
							"patterns": [
								{
									"include": "#type_keywords"
								},
								{
									"match": "[^\\.+]+",
									"name": "storage.type.powershell"
								},
								{
									"match": "\\.",
									"name": "punctuation.accessor.type.powershell.powershell"
								},
								{
									"match": "\\+",
									"name": "keyword.operator.type.powershell"
								}
							]
						}
					},
					"end": "(?=[^\\s])|(?<=])",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#type_SubType"
						},
						{
							"match": "(?<!])[^\\s\\[\\]+]+"
						}
					]
				},
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				}
			]
		},
		"type_keywords": {
			"comment": "primitive types and base classes often used",
			"patterns": [
				{
					"comment:": "[short], [ushort], [uint], [ulong] added PowerShell Core 6.2;",
					"match": "(?<![.\\w-])(?i:(?:value)?type|void|switch|(?:ps(?:custom)?)?object|pscredential|psmoduleinfo|hashtable|scriptblock|string|single|float|double|decimal|s?byte|bool(?:ean)?|char|datetime|array|bigint|u?int(?:32|16|64)?|u?long|u?short)(?![.\\w+`-])",
					"name": "keyword.type.powershell"
				},
				{
					"match": "(?<![.\\w-])(?i:system|math|text|convert|regex|xml)(?!\\w-)",
					"name": "support.class.powershell"
				}
			]
		},
		"advanceToToken": {
			"comment": "consume spaces and comments and line ends until the next token appears",
			"ignore": "\\G(?<=\\.|::)(?=[\\s#]|<#)",
			"begin": "\\G(?=[\\s#]|<#)",
			"end": "(?!\\s)(?!$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#commentLine"
				},
				{
					"include": "#commentBlock"
				}
			]
		},
		"accessors": {
			"patterns": [
				{
					"begin": "\\G(?:\\.(?!\\.)|(?<!:)::)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.accessor.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#members"
						},
						{
							"include": "#commentLine"
						},
						{
							"include": "#commentBlock"
						},
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "\\G(?=\\[)",
					"end": "(?!\\G)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\[",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.bracket.begin.powershell"
								}
							},
							"end": "]|(?!\\G)$(?=\\n)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.bracket.end.powershell"
								}
							},
							"name": "meta.index.powershell",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						},
						{
							"begin": "(?=\\.(?!\\.)|::|\\[)",
							"ignore": "(?=[^\\s\\p{L}]|\\n)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						}
					]
				},
				{
					"include": "#commentLine"
				},
				{
					"include": "#commentBlock"
				}
			]
		},
		"members": {
			"patterns": [
				{
					"begin": "(?<![\\])])(?:(?i:(foreach|where)(?=[\\({]))|([\\p{L}_]\\w*(?=\\()))",
					"captures": {
						"1": {
							"name": "support.function.$1.powershell"
						},
						"2": {
							"name": "variable.function.method.powershell"
						}
					},
					"end": "(?!\\G)|(?=\\))",
					"patterns": [
						{
							"begin": "\\G(?=\\()",
							"end": "(?!\\G)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\(",
									"beginCaptures": {
										"0": {
											"name": "punctuation.section.method-arguments.begin.powershell"
										}
									},
									"contentName": "meta.method-arguments.powershell",
									"end": "\\)",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.method-arguments.end.powershell"
										}
									},
									"patterns": [
										{
											"include": "#expression_mode"
										}
									]
								},
								{
									"begin": "(?=\\.(?!\\.)|::|\\[)",
									"ignore": "(?=[^\\s\\p{L}]|\\n)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#accessors"
										}
									]
								}
							]
						},
						{
							"begin": "\\G(?=\\{)",
							"end": "(?!\\G)",
							"patterns": [
								{
									"include": "#scriptblock"
								}
							]
						}
					]
				},
				{
					"begin": "(?<![\\])])[\\p{L}_]\\w*(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"beginCaptures": {
						"0": {
							"name": "variable.other.object.property.powershell"
						}
					},
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				},
				{
					"match": "(?<![\\])])[\\p{L}_]\\w*",
					"name": "variable.other.property.powershell"
				},
				{
					"comment": "need to wrap a begin block around this using \\G",
					"include": "#quotedStrings_Members"
				}
			]
		},
		"variable_inner": {
			"comment": "separate the parts of the variable name and scope them",
			"patterns": [
				{
					"match": "[$@][^:]*:$",
					"name": "invalid.character.variable.powershell"
				},
				{
					"captures": {
						"1": {
							"name": "constant.language.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"comment": "These are special constants.",
					"match": "(([$@])(?i:(:?(?:False|Null|True)))\\b)"
				},
				{
					"captures": {
						"1": {
							"name": "variable.language.builtin.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"comment": "These are the other built-in constants.",
					"match": "(([$@])(?i:(:?(?:Error|ExecutionContext|Host|Home|PID|PsHome|PsVersionTable|ShellID)\\b)))"
				},
				{
					"captures": {
						"1": {
							"name": "variable.language.builtin.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"match": "(([$@])(?i:((?:[$^?])|:\\?|:?(?:_|Args|ConsoleFileName|Event|EventArgs|EventSubscriber|ForEach|Input|LastExitCode|Matches|MyInvocation|NestedPromptLevel|Profile|PSBoundParameters|PsCmdlet|PsCulture|PSDebugContext|PSItem|PSCommandPath|PSScriptRoot|PsUICulture|Pwd|Sender|SourceArgs|SourceEventArgs|StackTrace|Switch|This)\\b)))"
				},
				{
					"captures": {
						"1": {
							"name": "variable.language.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"comment": "Style preference variables as language variables so that they stand out.",
					"match": "(([$@])(?i:(:?(?:ConfirmPreference|DebugPreference|ErrorActionPreference|ErrorView|FormatEnumerationLimit|MaximumAliasCount|MaximumDriveCount|MaximumErrorCount|MaximumFunctionCount|MaximumHistoryCount|MaximumVariableCount|OFS|OutputEncoding|ProgressPreference|PsCulture|PSDebugContext|PSDefaultParameterValues|PSEmailServer|PSItem|PSModuleAutoloadingPreference|PSSenderInfo|PSSessionApplicationName|PSSessionConfigurationName|PSSessionOption|VerbosePreference|WarningPreference|WhatIfPreference)\\b)))"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.variable.powershell"
						},
						"2": {
							"patterns": [
								{
									"include": "#variable_scopeOrDrive"
								}
							]
						}
					},
					"match": "(?:([$@])(?:(?>([\\w][\\w?]*:(?!:)|:))?([\\w](?:[\\w?]|(?<!:):(?!:))*|[$^:])))",
					"name": "variable.other.readwrite.powershell"
				}
			]
		},
		"variable_scopeOrDrive": {
			"patterns": [
				{
					"match": "((?i:global|local|private|script|using|workflow))(`)?(:)",
					"captures": {
						"1": {
							"name": "storage.modifier.scope.powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					}
				},
				{
					"match": "(?i:(Alias|Cert|Env|Function|HKCU|HKLM|Variable|WSMan))(`)?(:)",
					"captures": {
						"1": {
							"name": "keyword.type.drive:powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					}
				},
				{
					"comment": "Unknown drive",
					"begin": "(?=.)",
					"end": ":",
					"endCaptures": {
						"0": {
							"name": "punctuation.separator.colon.powershell"
						}
					},
					"name": "storage.type.drive.powershell",
					"patterns": [
						{
							"match": "`(?:[`0abefnrtv{}\\n])",
							"name": "constant.character.escape.powershell"
						},
						{
							"include": "#unicodeEscape"
						}
					]
				}
			]
		},
		"variable_bracketed": {
			"begin": "(?=\\$\\{)",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(\\$)(\\{)",
					"beginCaptures": {
						"1": {
							"name": "punctuation.definition.variable.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.variable.braces.end.powershell"
						}
					},
					"name": "variable.other.readwrite.powershell",
					"patterns": [
						{
							"include": "#variable_bracketed_inside"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"variable_bracketed_inside": {
			"patterns": [
				{
					"comment": "capture a complete variable reference that appears on a single line and attempt to scope language variables"
				},
				{
					"comment": "this captures up to the first colon, and then matches up the capture",
					"match": "\\G(?:(?:[^`{}:]|`[`{}]?+)+:|:)",
					"captures": {
						"0": {
							"patterns": [
								{
									"include": "#variable_scopeOrDrive"
								}
							]
						}
					}
				},
				{
					"match": "`(?:[`0abefnrtv{}\\n])",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				},
				{
					"match": "{",
					"name": "invalid.character.powershell"
				}
			]
		},
		"variableNoProperty_bracketed": {
			"begin": "(?=\\$\\{)",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(\\$)(\\{)",
					"beginCaptures": {
						"1": {
							"name": "punctuation.definition.variable.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.variable.braces.end.powershell"
						}
					},
					"name": "variable.other.readwrite.powershell",
					"patterns": [
						{
							"include": "#variable_bracketed_inside"
						}
					]
				}
			]
		},
		"variable": {
			"patterns": [
				{
					"begin": "(?=\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]|\\{))",
					"end": "(?!\\G)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:])(?=\\.(?!\\.)|::|\\[)",
							"beginCaptures": {
								"0": {
									"patterns": [
										{
											"include": "#variable_inner"
										}
									]
								}
							},
							"ignore": "(?=[^\\s\\p{L}]|\\n)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						},
						{
							"match": "\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:])",
							"captures": {
								"0": {
									"patterns": [
										{
											"include": "#variable_inner"
										}
									]
								}
							}
						},
						{
							"include": "#variable_bracketed"
						}
					]
				},
				{
					"comment": "splatting cannot have members and certain characters following, including no line comment",
					"match": "(?>@(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]))(?![~`!@#$%^*<>\\]\\\\/\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}+-])",
					"captures": {
						"0": {
							"patterns": [
								{
									"include": "#variable_inner"
								}
							]
						}
					}
				}
			]
		},
		"variableNoProperty": {
			"begin": "(?=\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]|\\{))",
			"end": "(?!.\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:])",
					"end": "(?!.\\G)",
					"applyEndPatternLast": true,
					"captures": {
						"0": {
							"patterns": [
								{
									"include": "#variable_inner"
								}
							]
						}
					}
				},
				{
					"include": "#variableNoProperty_bracketed"
				}
			],
			"name": "meta.embedded.interpolated.powershell"
		},
		"RequiresDirective": {
			"begin": "(?<=#)(?i:requires)(?=\\s)",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.requires.powershell"
				}
			},
			"end": "$",
			"name": "meta.requires.powershell",
			"patterns": [
				{
					"match": "[\\x{2013}-\\x{2015}-](?i:Modules|PSSnapin|RunAsAdministrator|ShellId|Version)",
					"name": "keyword.other.powershell"
				},
				{
					"match": "(?<!\\x{2013}-\\x{2015}-)\\b\\p{L}+|\\d+(?:\\.\\d+)*",
					"name": "variable.parameter.powershell"
				},
				{
					"match": ",",
					"name": "punctuation.separator.powershell"
				},
				{
					"include": "#hashtable"
				},
				{
					"include": "#notCode"
				}
			]
		},
		"hashtable": {
			"begin": "(?=@\\{)",
			"end": "(?!.\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(@)(\\{)",
					"beginCaptures": {
						"1": {
							"name": "keyword.other.hashtable.begin.powershell"
						},
						"2": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "\\}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.hashtable.powershell",
					"patterns": [
						{
							"match": "\\b(\\w+)(?=\\s*=)",
							"name": "entity.name.variable.property.powershell"
						},
						{
							"include": "#type"
						},
						{
							"include": "#variable"
						},
						{
							"include": "#quotedStrings_Members"
						},
						{
							"begin": "=",
							"beginCaptures": {
								"0": {
									"name": "keyword.operator.assignment.hashtable-member.powershell"
								}
							},
							"end": "(?=[;}\\n])",
							"patterns": [
								{
									"include": "#command_mode"
								}
							]
						},
						{
							"include": "#terminators"
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignore": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"quotedStrings_Members": {
			"begin": "(?=@?(['\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}])(?:(?<!@\\g<1>)|\\s*$))",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "['\\x{2018}-\\x{201B}]",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.powershell"
						}
					},
					"end": "['\\x{2018}-\\x{201B}]",
					"applyEndPatternLast": true,
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.powershell"
						}
					},
					"name": "string.quoted.single.powershell",
					"patterns": [
						{
							"match": "['\\x{2018}-\\x{201B}]{2}",
							"name": "constant.character.escape.powershell"
						}
					]
				},
				{
					"begin": "@(?:[\"\\x{201C}-\\x{201E}])(?=\\s*$)",
					"end": "^(?:[\"\\x{201C}-\\x{201E}])@",
					"name": "string.quoted.double.heredoc.powershell",
					"patterns": [
						{
							"include": "#variableNoProperty"
						},
						{
							"include": "#doubleQuotedHereStringEscapes"
						},
						{
							"include": "#substatementNoProperty"
						}
					]
				},
				{
					"begin": "@['\\x{2018}-\\x{201B}](?=\\s*$)",
					"end": "^['\\x{2018}-\\x{201B}]@",
					"name": "string.quoted.single.heredoc.powershell"
				},
				{
					"begin": "(?:[\"\\x{201C}-\\x{201E}])",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.powershell"
						}
					},
					"end": "(?:[\"\\x{201C}-\\x{201E}])",
					"applyEndPatternLast": true,
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.powershell"
						}
					},
					"name": "string.quoted.double.powershell",
					"patterns": [
						{
							"include": "#variableNoProperty"
						},
						{
							"include": "#doubleQuotedStringEscapes"
						},
						{
							"include": "#substatementNoProperty"
						}
					]
				},
				{
					"ignoreBegin": "(?<=^(['\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}])@|(?<=\\g<1>))(?=\\.(?!\\.)|::|\\[)",
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"ignoreEnd": "(?=[^\\s\\p{L}]|\\n)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"functionName": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#argumentModeEscapes"
				},
				{
					"begin": "['\\x{2018}-\\x{201B}]",
					"end": "['\\x{2018}-\\x{201B}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"match": "['\\x{2018}-\\x{201B}]{2}",
							"name": "constant.character.escape.powershell"
						}
					]
				},
				{
					"begin": "[\"\\x{201C}-\\x{201E}]",
					"end": "[\"\\x{201C}-\\x{201E}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#doubleQuotedStringEscapes"
						},
						{
							"begin": "\\$\\(",
							"end": "\\)",
							"patterns": [
								{
									"include": "#functionName"
								}
							]
						}
					]
				},
				{
					"begin": "\\$\\(",
					"end": "\\)",
					"patterns": [
						{
							"include": "#functionName"
						}
					]
				}
			]
		},
		"unquotedStrings_text": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#argumentModeEscapes"
				},
				{
					"include": "#variableNoProperty"
				},
				{
					"include": "#quotedStrings_Members"
				},
				{
					"include": "#substatementNoProperty"
				}
			]
		},
		"unquotedStrings_text_interpolatedString": {
			"comment": "!!!!!!!!!!!!!!!!!!WIP!!!",
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#argumentModeEscapes"
				},
				{
					"begin": "['\\x{2018}-\\x{201B}]",
					"end": "['\\x{2018}-\\x{201B}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"match": "['\\x{2018}-\\x{201B}]{2}",
							"name": "constant.character.escape.powershell"
						}
					]
				},
				{
					"begin": "[\"\\x{201C}-\\x{201E}]",
					"end": "[\"\\x{201C}-\\x{201E}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#doubleQuotedStringEscapes"
						},
						{
							"begin": "\\$\\(",
							"end": "\\)",
							"patterns": [
								{
									"include": "#unquotedStrings_text"
								}
							]
						}
					]
				},
				{
					"begin": "\\$\\(",
					"end": "\\)",
					"patterns": [
						{
							"include": "#unquotedStrings_text"
						}
					]
				}
			]
		},
		"jobOperator": {
			"comment": "`&` resume's in statement mode",
			"begin": "&(?!&)",
			"beginCaptures": {
				"0": {
					"name": "punctuation.separator.job.powershell"
				}
			},
			"end": "$(?=\\n)|(?=[;|)}\\]])",
			"patterns": [
				{
					"include": "$self"
				}
			]
		},
		"terminators": {
			"patterns": [
				{
					"comment": "`;` resume's in statement mode.",
					"match": ";",
					"name": "punctuation.terminator.statement.powershell"
				},
				{
					"comment": "`,` just continues current mode",
					"match": ",",
					"name": "punctuation.separator.powershell"
				}
			]
		},
		"operators_postUnary": {
			"patterns": [
				{
					"match": "(\\+\\+)|([\\x{2013}-\\x{2015}-]{2})",
					"captures": {
						"1": {
							"name": "keyword.operator.arithmetic.postfix.unary.increment.powershell"
						},
						"2": {
							"name": "keyword.operator.arithmetic.postfix.unary.decrement.powershell"
						}
					}
				}
			]
		},
		"operators_preUnary": {
			"patterns": [
				{
					"begin": "(\\+\\+)|([\\x{2013}-\\x{2015}-]{2})",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.arithmetic.prefix.unary.increment.powershell"
						},
						"2": {
							"name": "keyword.operator.arithmetic.prefix.unary.decrement.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"include": "#numericConstant"
				},
				{
					"begin": "(?:(?=[\\x{2013}-\\x{2015}-])(?i:(.not)|(.bnot)|(.))|(!))(?!\\p{L})",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.logical.unary.not.powershell"
						},
						"2": {
							"name": "keyword.operator.bitwise.unary.bnot.powershell"
						},
						"3": {
							"name": "keyword.operator.arithmetic.unary.negate.powershell"
						},
						"4": {
							"name": "keyword.operator.logical.unary.not.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				}
			]
		},
		"operators": {
			"patterns": [
				{
					"include": "#operators_postUnary"
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-](?i:is(?:not)?|as)(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.comparison.type.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:[ic]?(?:eq|ne|[gl][te]|(?:not)?(?:like|match|contains|in)|replace)))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.comparison.$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:join|[ic]?split))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.string-$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:and|or|xor))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.logical.$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:band|bor|bxor|shl|shr))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.bitwise.$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-](?i:f)(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.string-format.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[+%*/\\x{2013}-\\x{2015}-]?=",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.assignment.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[,;&|)}\\]])",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "[+%*/]|[\\x{2013}-\\x{2015}-](?![\\p{L}\\x{2013}-\\x{2015}-])",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.arithmetic.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"comment": "the range operator is only available after an operand (binary operator)",
					"begin": "(?<!^)\\s*(\\.\\.)",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.range.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"comment": "included last only because preunary also includes the negate `!` and `-b?not` operators",
					"include": "#operators_preUnary"
				}
			]
		},
		"notCode": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "invalid.character.escape.powershell"
				},
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				},
				{
					"comment": "when nothing else matches in usual tokenizing, consume it to prevent other patterns from striking in the middle of what might be a command name.",
					"begin": "(?=[^\\s\\[(){},;&|])",
					"alternateBegin": "(?=[^\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}\\s\\[(){},;&|$@])|(?<=\\S)(?=[$@<>])",
					"end": "(?=[\\s{(,;&|)}])",
					"contentName": "invalid.source.powershell",
					"patterns": [
						{
							"include": "#unquotedStrings_text"
						}
					]
				}
			]
		},
		"redirection": {
			"match": "([2-6*]>&1|[1-6*]?>>?)|(<(?!#))",
			"captures": {
				"1": {
					"name": "keyword.operator.redirection.powershell"
				},
				"2": {
					"name": "invalid.reserved.redirection.powershell"
				}
			}
		}
	}
}