{
	"information_for_contributors": [
		"This file has been converted from https://github.com/PowerShell/EditorSyntax/blob/master/PowerShellSyntax.tmLanguage",
		"If you want to provide a fix or improvement, please create a pull request against the original repository.",
		"Once accepted there, we are happy to receive an update request."
	],
	"version": "altered from https://github.com/PowerShell/EditorSyntax/commit/472c9447da4e3160bef211d5e1a0c2dee3cce497",
	"name": "PowerShell",
	"scopeName": "source.powershell",
	"patterns": [
		{
			"comment": "type without accessor or attribute needed in statement mode, mostly for [flags()] before an `enum`.",
			"include": "#type"
		},
		{
			"include": "#RequiresDirective"
		},
		{
			"comment": "`;` resume's in statement mode.",
			"begin": ";",
			"beginCaptures": {
				"0": {
					"name": "punctuation.terminator.statement.powershell"
				}
			},
			"end": "$(?=\\n)|(?=[;)}\\]])",
			"patterns": [
				{
					"comment": "$self may have been combined with other includes, this will insure its just $self now",
					"include": "$self"
				}
			]
		},
		{
			"begin": "(?i:class)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.other.class.powershell"
				}
			},
			"end": "}|(?=[^\\s])",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.braces.end.powershell"
				}
			},
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "[\\p{L}_]\\w*",
					"beginCaptures": {
						"0": {
							"name": "entity.name.type.class.powershell"
						}
					},
					"end": "(?=[^\\s])",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": ":",
							"beginCaptures": {
								"0": {
									"name": "punctuation.separator.colon.powershell"
								}
							},
							"end": "(?=[^\\s:])",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
									"beginCaptures": {
										"0": {
											"patterns": [
												{
													"include": "#type_keywords"
												},
												{
													"match": "[^\\.]+",
													"name": "entity.other.inherited-class.powershell"
												},
												{
													"match": "\\.",
													"name": "punctuation.accessor.type.powershell"
												}
											]
										}
									},
									"end": "(?=[^\\s])",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": ",",
											"beginCaptures": {
												"0": {
													"name": "punctuation.separator.comma.powershell"
												}
											},
											"end": "(?=[^\\s:])",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
													"beginCaptures": {
														"0": {
															"patterns": [
																{
																	"include": "#type_keywords"
																},
																{
																	"match": "[^\\.]+",
																	"name": "entity.other.inherited-class.powershell"
																},
																{
																	"match": "\\.",
																	"name": "punctuation.accessor.type.powershell"
																}
															]
														}
													},
													"end": "(?=[^\\s])",
													"applyEndPatternLast": true,
													"patterns": [
														{
															"include": "#notCode"
														}
													]
												},
												{
													"include": "#notCode"
												}
											]
										},
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "(?=})",
					"contentName": "meta.class.powershell",
					"patterns": [
						{
							"match": "((?i:hidden|static))(?![^\\s{(,;&|)}])",
							"name": "storage.modifier.powershell"
						},
						{
							"begin": "(?=[\\p{L}_])",
							"end": "}|(?=[^\\s])|$(?=\\n)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"applyEndPatternLast": true,
							"name": "meta.method.powershell",
							"patterns": [
								{
									"match": "`\\n",
									"name": "constant.character.escape.powershell"
								},
								{
									"begin": "\\G([\\p{L}_]\\w*)",
									"beginCaptures": {
										"1": {
											"name": "entity.name.function.powershell"
										}
									},
									"end": "(?=[^\\s])|$(?=\\n)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": "(?=\\()",
											"end": "(?=[^\\s])",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": ":",
													"beginCaptures": {
														"0": {
															"name": "punctuation.separator.colon.powershell"
														}
													},
													"end": "(?=[;{])",
													"patterns": [
														{
															"begin": "(?i:base)(?![^\\s{(,;&|)}])",
															"beginCaptures": {
																"0": {
																	"name": "variable.language.super.powershell"
																}
															},
															"end": "(?=[;{])",
															"patterns": [
																{
																	"include": "#declarationParameterSet"
																}
															]
														}
													]
												},
												{
													"include": "#declarationParameterSet"
												},
												{
													"begin": "{",
													"beginCaptures": {
														"0": {
															"name": "punctuation.section.braces.begin.powershell"
														}
													},
													"end": "(?=})",
													"contentName": "meta.method-body.powershell",
													"patterns": [
														{
															"include": "$self"
														}
													]
												},
												{
													"include": "#notCode"
												}
											]
										},
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "$self"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "((?i:enum))(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"1": {
					"name": "keyword.other.enum.powershell"
				}
			},
			"end": "(?=[^\\s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "([\\p{L}_]\\w*)",
					"beginCaptures": {
						"1": {
							"name": "entity.name.type.enum.powershell"
						}
					},
					"end": "(?=[^\\s])|(?<=})",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"comment": "optional user specified type, PowerShell Core >= 6.2.0",
							"begin": ":",
							"beginCaptures": {
								"0": {
									"name": "punctuation.separator.colon.powershell"
								}
							},
							"end": "(?=[^\\s:])|(?<=})",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
									"beginCaptures": {
										"0": {
											"patterns": [
												{
													"include": "#type_Disolve"
												}
											]
										}
									},
									"end": "(?=[^\\s])|(?<=})",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.enumeration.powershell",
					"patterns": [
						{
							"match": ";",
							"name": "punctuation.terminator.statement.powershell"
						},
						{
							"begin": "([\\p{L}_]\\w*)",
							"beginCaptures": {
								"1": {
									"name": "entity.name.variable.enum-member.powershell"
								}
							},
							"end": "(?=[#;&|}\\n])",
							"patterns": [
								{
									"begin": "=",
									"beginCaptures": {
										"0": {
											"name": "keyword.operator.assignment.enum-member.powershell"
										}
									},
									"end": "(?=[#;&|}\\n])",
									"patterns": [
										{
											"comment": "begin at the first token in the expression, to test for numeric and unary operators",
											"begin": "(?![\\s#]|<#|`\\n)(?!$(?=\\n)|[;&|)}\\]])",
											"end": "(?=.|$)",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"comment": "allow for possibility that numeric value or unary operators match first, before resuming in expression mode",
													"begin": "(?!\\G)(?!$(?=\\n)|[;&|)}\\]])",
													"end": "$(?=\\n)|(?=[;&|)}\\]])",
													"patterns": [
														{
															"include": "#expression_mode"
														}
													]
												},
												{
													"include": "#numericConstant"
												},
												{
													"include": "#operators_preUnary"
												},
												{
													"comment": "if neither numeric or a pre-unary operator, just finish in expression mode",
													"begin": "(?!$(?=\\n)|[;&|)}\\]])",
													"end": "$(?=\\n)|(?=[;&|)}\\]])",
													"patterns": [
														{
															"include": "#expression_mode"
														}
													]
												}
											]
										},
										{
											"include": "#commentBlock"
										},
										{
											"comment": "normally provided by command mode, but thats not available here",
											"match": "`\\n",
											"name": "constant.character.escape.powershell"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"comment": "`,`, `&` and `|` not permitted here",
							"match": "[,&|]",
							"name": "invalid.source.powershell"
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:function|filter|workflow)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.other.$0.powershell"
				}
			},
			"end": "(?=[//s])|(?<=})",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(?:(global|local|script|private)(`)?(:)(?=[^\\s{(,;&)}])|(?=[^`\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}\\s{(,;&)}<>@#\\]]|`(?!\\s)))",
					"beginCaptures": {
						"1": {
							"name": "storage.modifier.scope.powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					},
					"end": "(?=[//s])|(?<=})",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G",
							"end": "(?=[\\s{(,;&)}])",
							"name": "entity.name.function.powershell",
							"patterns": [
								{
									"comment": "function names that start with `:` are treated differently",
									"match": "\\G(?<!:):\\p{L}\\w*[^\\s{(,;&)}]?"
								},
								{
									"include": "#functionName"
								}
							]
						},
						{
							"begin": "(?<!\\G)(?<!})",
							"end": "(?=[//s])|(?<=})",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "{",
									"beginCaptures": {
										"0": {
											"name": "punctuation.section.braces.begin.powershell"
										}
									},
									"end": "}",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.braces.end.powershell"
										}
									},
									"name": "meta.function.powershell",
									"patterns": [
										{
											"include": "$self"
										}
									]
								},
								{
									"include": "#declarationParameterSet"
								},
								{
									"include": "#notCode"
								}
							]
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "do,for,foreach,switch,while: allow a `:label` that must start the statement; A `:label` before a loop looks just like a function, and its possible to put the loop keyword on a later line!  Here we just see if a valid label appears to be the only useful thing on a single line",
			"match": "(?>(:)([\\p{L}_]\\w*)(?![^\\s{(,;&|)}]))(?=(?>(?:`\\s|\\s*<#.*?#>)*)\\s*(?:(?i:do|for(?:each)?|switch|while)(?![^\\s{(,;&|)}])|#|<#.*$|`?$))",
			"captures": {
				"1": {
					"name": "punctuation.separator.colon.label.powershell"
				},
				"2": {
					"name": "entity.name.label.powershell"
				},
				"3": {
					"patterns": [
						{
							"include": "#commentBlock"
						}
					]
				}
			}
		},
		{
			"comment": "break,continue: permit a label following, then revert back to statement mode",
			"begin": "(?i:break|continue)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.$0.powershell"
				}
			},
			"end": "[\\p{L}_]\\w*|(?=$\\n|\\S)",
			"endCaptures": {
				"0": {
					"name": "entity.name.label.powershell"
				}
			},
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#commentBlock"
				}
			]
		},
		{
			"begin": "(?i:exit|return|throw)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.$0.powershell"
				}
			},
			"end": "$(?=\\n)|(?=[;)}\\]])",
			"patterns": [
				{
					"include": "#command_mode"
				}
			]
		},
		{
			"begin": "(?i:foreach)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.foreach.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(?=\\()",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\(",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.group.begin.powershell"
								}
							},
							"name": "meta.foreach-set.powershell",
							"end": "\\)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.group.end.powershell"
								}
							},
							"patterns": [
								{
									"begin": "(?i:in)",
									"beginCaptures": {
										"0": {
											"name": "keyword.control.foreach-in.powershell"
										}
									},
									"end": "(?=[;)])",
									"patterns": [
										{
											"include": "#command_mode"
										}
									]
								},
								{
									"include": "#variableNoProperty"
								},
								{
									"include": "#type"
								},
								{
									"comment": "`;` not permitted here",
									"match": ";",
									"name": "invalid.terminator.statement.powershell"
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"begin": "(?<=\\))(?![,)}])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?={)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": "\\G\\{",
											"beginCaptures": {
												"0": {
													"name": "punctuation.section.braces.begin.powershell"
												}
											},
											"end": "}",
											"endCaptures": {
												"0": {
													"name": "punctuation.section.braces.end.powershell"
												}
											},
											"name": "meta.statements.foreach-loop.powershell",
											"patterns": [
												{
													"include": "$self"
												}
											]
										},
										{
											"comment": "next statement, return when safe to exit",
											"begin": "(?<=})(?![,)}\\]])",
											"end": "(?<![}\\)])(?=\\n)|(?=[,})\\]])",
											"applyEndPatternLast": false,
											"patterns": [
												{
													"include": "$self"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"comment": "only allow foreach arguments before the `(`",
					"begin": "\\G(?=[\\s#\\x{2013}-\\x{2015}-]|<#)",
					"end": "(?![\\s#\\x{2013}-\\x{2015}-]|<#)",
					"patterns": [
						{
							"comment": "-parallel parameter can only be used in a workflow, consider using meta scopes, and an injection to properly catch this",
							"match": "(?i:[\\x{2013}-\\x{2015}-]parallel)(?:(:)?|(?![^\\s{(,;&|)}]))",
							"beginCaptures": {
								"1": {
									"name": "entity.name.parameter.foreach-parallel.powershell"
								},
								"2": {
									"name": "punctuation.separator.parameter-value.powershell"
								}
							}
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"match": "[,<>]",
					"name": "invalid.source.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:while)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.while.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?=\\()",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\(",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.group.begin.powershell"
								}
							},
							"end": "\\)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.group.end.powershell"
								}
							},
							"name": "meta.while-condition.powershell",
							"patterns": [
								{
									"comment": "`;` not permitted here",
									"match": ";",
									"name": "invalid.source.powershell"
								},
								{
									"include": "#command_mode"
								}
							]
						},
						{
							"begin": "(?<=\\))(?![,)}])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?={)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": "\\G\\{",
											"beginCaptures": {
												"0": {
													"name": "punctuation.section.braces.begin.powershell"
												}
											},
											"end": "}",
											"endCaptures": {
												"0": {
													"name": "punctuation.section.braces.end.powershell"
												}
											},
											"name": "meta.statements.while-loop.powershell",
											"patterns": [
												{
													"include": "$self"
												}
											]
										},
										{
											"comment": "next statement, return when safe to exit",
											"begin": "(?<=})(?![,)}\\]])",
											"end": "(?<![}\\)])(?=\\n)|(?=[,})\\]])",
											"applyEndPatternLast": false,
											"patterns": [
												{
													"include": "$self"
												}
											]
										}
									]
								},
								{
									"comment": "very limited what is permitted here",
									"ignore": "[^\\s{()}]",
									"name": "invalid.source.powershell"
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"comment": "very limited what is permitted here",
							"ignore": "[^\\s{]",
							"name": "invalid.source.powershell"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"ignore": "[,<>]",
					"name": "invalid.source.powershell"
				},
				{
					"ignore": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:for)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.for.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?=\\()",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\(",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.group.begin.powershell"
								}
							},
							"end": "\\)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.group.end.powershell"
								}
							},
							"name": "meta.for-condition.powershell",
							"patterns": [
								{
									"comment": "`;` here resumes in command mode",
									"match": ";",
									"name": "punctuation.terminator.statement.powershell"
								},
								{
									"include": "#command_mode"
								}
							]
						},
						{
							"begin": "(?<=\\))(?![,)}])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?={)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": "\\G\\{",
											"beginCaptures": {
												"0": {
													"name": "punctuation.section.braces.begin.powershell"
												}
											},
											"end": "}",
											"endCaptures": {
												"0": {
													"name": "punctuation.section.braces.end.powershell"
												}
											},
											"name": "meta.statements.for-loop.powershell",
											"patterns": [
												{
													"include": "$self"
												}
											]
										},
										{
											"comment": "next statement, return when safe to exit",
											"begin": "(?<=})(?![,)}\\]])",
											"end": "(?<![}\\)])(?=\\n)|(?=[,})\\]])",
											"applyEndPatternLast": false,
											"patterns": [
												{
													"include": "$self"
												}
											]
										}
									]
								},
								{
									"comment": "very limited what is permitted here",
									"ignore": "[^\\s{()}]",
									"name": "invalid.source.powershell"
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"comment": "very limited what is permitted here",
							"ignore": "[^\\s{]",
							"name": "invalid.source.powershell"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"ignore": "[,<>]",
					"name": "invalid.source.powershell"
				},
				{
					"ignore": "#notCode"
				}
			]
		},
		{
			"comment": "until/while (condition) ends do {statements}",
			"begin": "(?i:do)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.do.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?={)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\{",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.begin.powershell"
								}
							},
							"end": "}",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"name": "meta.statements.do-loop.powershell",
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"begin": "(?<=})(?![,;&|)}])",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?i:while)(?![^\\s{(,;&|)}])",
									"beginCaptures": {
										"0": {
											"name": "keyword.control.do-while.powershell"
										}
									},
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										},
										{
											"begin": "(?=\\()",
											"end": "(?=.|$)",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": "\\G\\(",
													"beginCaptures": {
														"0": {
															"name": "punctuation.section.group.begin.powershell"
														}
													},
													"end": "\\)",
													"endCaptures": {
														"0": {
															"name": "punctuation.section.group.end.powershell"
														}
													},
													"name": "meta.while-condition.powershell",
													"patterns": [
														{
															"comment": "`;` not permitted here",
															"match": ";",
															"name": "invalid.source.powershell"
														},
														{
															"include": "#command_mode"
														}
													]
												},
												{
													"begin": "(?<=\\))(?![,)}]|$)",
													"end": "(?=[\\S])",
													"applyEndPatternLast": true,
													"patterns": [
														{
															"include": "$self"
														}
													]
												}
											]
										}
									]
								},
								{
									"begin": "(?i:until)(?![^\\s{(,;&|)}])",
									"beginCaptures": {
										"0": {
											"name": "keyword.control.do-until.powershell"
										}
									},
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										},
										{
											"begin": "(?=\\()",
											"end": "(?=.|$)",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": "\\G\\(",
													"beginCaptures": {
														"0": {
															"name": "punctuation.section.group.begin.powershell"
														}
													},
													"end": "\\)",
													"endCaptures": {
														"0": {
															"name": "punctuation.section.group.end.powershell"
														}
													},
													"name": "meta.until-condition.powershell",
													"patterns": [
														{
															"comment": "`;` not permitted here",
															"match": ";",
															"name": "invalid.source.powershell"
														},
														{
															"include": "#command_mode"
														}
													]
												},
												{
													"comment": "next statement, return when safe to exit",
													"begin": "(?<=\\))(?![,)}\\]])",
													"end": "(?<![}\\)])(?=\\n)|(?=[,})\\]])",
													"applyEndPatternLast": false,
													"patterns": [
														{
															"include": "$self"
														}
													]
												}
											]
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "else,elseif: only after if,elseif",
			"begin": "(?i:if)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.if.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#ifPattern"
				}
			]
		},
		{
			"begin": "(?i:switch)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.switch.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(?=\\()",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\(",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.group.begin.powershell"
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\G",
									"contentName": "meta.switch-value.powershell",
									"end": "\\)",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.group.end.powershell"
										}
									},
									"patterns": [
										{
											"comment": "`;` not permitted here",
											"match": ";",
											"name": "invalid.source.powershell"
										},
										{
											"include": "#command_mode"
										}
									]
								},
								{
									"begin": "(?<=\\))(?![,)}])",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										},
										{
											"include": "#switchConditions"
										},
										{
											"include": "#notCode"
										},
										{
											"comment": "very limited what is permitted here",
											"ignore": "[^\\s{]",
											"name": "invalid.source.powershell"
										}
									]
								}
							]
						}
					]
				},
				{
					"include": "#switchConditions"
				},
				{
					"comment": "only allow switch arguments before the `(` or `{`",
					"begin": "\\G(?=[\\s#\\x{2013}-\\x{2015}-]|<#)",
					"end": "(?![\\s#\\x{2013}-\\x{2015}-]|<#)",
					"patterns": [
						{
							"match": "((?i:[\\x{2013}-\\x{2015}-](regex|wildcard|exact|casesensitive)))(?:(:)?|(?![^\\s{(,;&|)}]))",
							"captures": {
								"1": {
									"name": "entity.name.parameter.switch-$2.powershell"
								},
								"3": {
									"name": "punctuation.separator.parameter-value.powershell"
								}
							}
						},
						{
							"comment": "-file is special case, needs file argument, no condition expression",
							"begin": "((?i:[\\x{2013}-\\x{2015}-]file))(?:(:)?|(?![^\\s{(,;&|)}]))",
							"beginCaptures": {
								"1": {
									"name": "entity.name.parameter.switch-file.powershell"
								},
								"2": {
									"name": "punctuation.separator.parameter-value.powershell"
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\G(?![,;&|)}<>])",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										},
										{
											"begin": "(?<=[\\s>]|\\G|^)(?![\\s#,;&|)}<>]|<#|$)",
											"end": "(?!\\G)",
											"name": "meta.argument.switch-file.powershell",
											"patterns": [
												{
													"include": "#argument"
												}
											]
										}
									]
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"match": "[,<>]",
					"name": "invalid.source.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"begin": "(?i:trap)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.trap.powershell"
				}
			},
			"end": "(?=\\S|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"comment": "only one [exception] argument before the `{`",
					"begin": "\\G(?=[\\s#\\[]|<#)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"begin": "(?=\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "(?<=])(?![,)}])",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										},
										{
											"begin": "(?={)",
											"end": "(?=.|$)",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"begin": "\\G\\{",
													"beginCaptures": {
														"0": {
															"name": "punctuation.section.braces.begin.powershell"
														}
													},
													"end": "}",
													"endCaptures": {
														"0": {
															"name": "punctuation.section.braces.end.powershell"
														}
													},
													"name": "meta.statements.trap.powershell",
													"patterns": [
														{
															"include": "$self"
														}
													]
												},
												{
													"comment": "next statement, return when safe to exit",
													"begin": "(?<=})(?![,)}\\]])",
													"end": "(?<![}\\]])(?=\\n)|(?=[,})\\]])",
													"applyEndPatternLast": false,
													"patterns": [
														{
															"include": "$self"
														}
													]
												}
											]
										},
										{
											"comment": "`,`, `<` and `>` not permitted here",
											"match": "[,\\(\\[\\]<>]",
											"name": "invalid.source.powershell"
										}
									]
								},
								{
									"include": "#type"
								}
							]
						},
						{
							"ignore": "#notCode"
						}
					]
				},
				{
					"begin": "(?={)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\{",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.begin.powershell"
								}
							},
							"end": "}",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"name": "meta.statements.trap.powershell",
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"comment": "next statement, return when safe to exit",
							"begin": "(?<=})(?![,)}\\]])",
							"end": "(?<![}\\]])(?=\\n)|(?=[,})\\]])",
							"applyEndPatternLast": false,
							"patterns": [
								{
									"include": "$self"
								}
							]
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"match": "[,\\(\\[\\]<>]",
					"name": "invalid.source.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "catch/finally only after try",
			"begin": "(?i:try)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.try.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?={)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\{",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.begin.powershell"
								}
							},
							"end": "}",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"name": "meta.statements.try.powershell",
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"begin": "(?<=})(?![,;&|)}])",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#catchClause"
								}
							]
						}
					]
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "data: parameter `-supportedCommand` is array of cmdlets (function names)",
			"begin": "(?i:data)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.$0.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"comment": "only allow data parameters before the `{`",
					"begin": "\\G(?=[\\s#\\x{2013}-\\x{2015}-]|<#)",
					"end": "(?![\\s#\\x{2013}-\\x{2015}-]|<#)",
					"patterns": [
						{
							"comment": "-supportedcommand is special case, array of arguments",
							"begin": "((?i:[\\x{2013}-\\x{2015}-]supportedcommand))(?:(:)?|(?![^\\s{(,;&|)}]))",
							"beginCaptures": {
								"1": {
									"name": "entity.name.parameter.data-supportedcommand.powershell"
								},
								"2": {
									"name": "punctuation.separator.parameter-value.powershell"
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"match": ",",
									"name": "punctuation.separator.powershell"
								},
								{
									"begin": "(?:\\G|(?<=,))(?![;&|)}<>])",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										},
										{
											"begin": "(?<=[\\s>]|\\G|^)(?![\\s#,;&|)}<>]|<#|$)",
											"end": "(?!\\G)",
											"name": "meta.argument.data-supportedcommand.powershell",
											"patterns": [
												{
													"include": "#argument"
												}
											]
										}
									]
								}
							]
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "(?={)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\{",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.begin.powershell"
								}
							},
							"end": "}",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"name": "meta.statements.data-section.powershell",
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"comment": "next statement, return when safe to exit",
							"begin": "(?<=})(?![,)}\\]])",
							"end": "(?<!})(?=\\n)|(?=[,})\\]])",
							"applyEndPatternLast": false,
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"comment": "very limited what is permitted here",
							"ignore": "[^\\s{}]",
							"name": "invalid.source.powershell"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"match": "[,\\[\\]<>]",
					"name": "invalid.source.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "inlinescript,parallel,sequence: only in workflow; ",
			"begin": "(?i:begin|dynamicparam|end|inlinescript|parallel|process|sequence)(?![^\\s{(,;&|)}])",
			"beginCaptures": {
				"0": {
					"name": "keyword.control.$0.powershell"
				}
			},
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?={)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\{",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.begin.powershell"
								}
							},
							"end": "}",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"name": "meta.statement-block.powershell",
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"comment": "next statement, return when safe to exit",
							"begin": "(?<=})(?![,)}\\]])",
							"end": "(?<!})(?=\\n)|(?=[,})\\]])",
							"applyEndPatternLast": false,
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"comment": "very limited what is permitted here",
							"ignore": "[^\\s{}]",
							"name": "invalid.source.powershell"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"match": "[,\\[\\]<>]",
					"name": "invalid.source.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		{
			"comment": "the argument is permitted to be quoted; TODO",
			"match": "(?i:(using))\\s+(?i:(assembly|namespace|module))\\s+((?:[\\p{L}_]\\w*\\.?)+)",
			"captures": {
				"1": {
					"name": "keyword.control.using.powershell"
				},
				"2": {
					"name": "keyword.other.powershell"
				},
				"3": {
					"patterns": [
						{
							"include": "#type_Disolve"
						}
					]
				}
			}
		},
		{
			"comment": "from,var,define are reserved; configuration is TODO, needs significant syntax structure work.",
			"match": "(?i:configuration|define|from|var)(?![^\\s{(,;&|)}])",
			"name": "invalid.reserved.keyword.control.$0.powershell"
		},
		{
			"comment": "param: only in main body or a function main body, and only if followed by parameter declaration",
			"match": "(?i:param)(?![^\\s{(,;&|)}])",
			"name": "keyword.control.$0.powershell"
		},
		{
			"include": "#command_mode"
		}
	],
	"repository": {
		"command_mode": {
			"patterns": [
				{
					"comment": "`||` and `&&` conditional terminators are reserved.",
					"match": "\\|\\||&&",
					"name": "invalid.reserved.powershell"
				},
				{
					"comment": "(dot) source operator, requires trailing space, or invoke operator",
					"begin": "&|\\.(?=[\\s{(,;&|)}\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}]|\\$[\\p{L}$?^:_{(])",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.invoke-or-source.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;)}\\]])",
					"patterns": [
						{
							"comment": "Next token needs to be an operand for the operator, not the actual command, but an expression or unquoted expandable string that describes the command's name.",
							"begin": "\\G(?![,;&|)}<>])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?<=[\\s>]|\\G|^)(?![\\s#,;&|)}<>]|<#|$)",
									"end": "(?!\\G)",
									"name": "meta.argument.invoke-or-source.powershell",
									"patterns": [
										{
											"include": "#argument"
										}
									]
								}
							]
						},
						{
							"comment": "Next token needs to be an operand for the operator, not the actual command, but an expression or unquoted expandable string that describes the command's name.",
							"begin": "(?![\\n;)}\\]])",
							"end": "$(?=\\n)|(?=[;)}\\]])",
							"patterns": [
								{
									"include": "#argument_mode"
								}
							]
						}
					]
				},
				{
					"comment": "could be a numeric constant or a limited list of unary operators, that we should switch to expression mode",
					"begin": "(?=[\\d.!+\\x{2013}-\\x{2015}-])",
					"end": "$(?=\\n)|(?=[;)}\\]])",
					"patterns": [
						{
							"comment": "if unary operators/numeric constant advanced, switch to expression mode",
							"begin": "(?:(?!\\G)|\\G(?=[^\\d.!+\\x{2013}-\\x{2015}-]|$))(?!$(?=\\n)|[;|)}\\]])",
							"end": "$(?=\\n)|(?=[;)}\\]])",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						},
						{
							"include": "#numericConstant"
						},
						{
							"comment": "if numeric constant didn't advanced, but it looks like a negative number should have matched, finishing command mode with a command name",
							"begin": "\\G(?=[\\x{2013}-\\x{2015}-][\\d.])(?!$(?=\\n)|[;|)}\\]])",
							"end": "$(?=\\n)|(?=[;)}\\]])",
							"patterns": [
								{
									"include": "#command_name"
								}
							]
						},
						{
							"include": "#operators_preUnary"
						},
						{
							"comment": "if numeric constant didn't advanced, try finishing command mode with a command name",
							"begin": "(?!$(?=\\n)|[;)}\\]])",
							"end": "$(?=\\n)|(?=[;)}\\]])",
							"patterns": [
								{
									"include": "#command_name"
								}
							]
						}
					]
				},
				{
					"comment": "patterns that indicate an expression, might be able to simplify this to include expression_mode and then see if the cursor advanced, sorta, don't forget about 'notCode', maybe check operand/operator only first, as redirect could also be a problem.",
					"begin": "(?=[$@][{(\\w:$?^]|[({]|[,\\[\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}])|(?=@?(['\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}])(?:(?<!@\\g<1>)|\\s*$))|(?=[\\x{2013}-\\x{2015}-][\\s#{(,;|)}<>.!+%*/=\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}\\x{2013}-\\x{2015}-])",
					"end": "$(?=\\n)|(?=[;)}\\]])",
					"patterns": [
						{
							"include": "#expression_mode"
						}
					]
				},
				{
					"match": "`\\n",
					"name": "constant.character.escape.powershell"
				},
				{
					"match": "`\\s",
					"name": "invalid.character.escape.powershell"
				},
				{
					"match": "\\|",
					"name": "invalid.empty-pipe.powershell"
				},
				{
					"include": "#command_name"
				},
				{
					"comment": "catch that which didn't match elsewhere",
					"match": "[^\\s]",
					"name": "invalid.source.powershell"
				}
			]
		},
		"command_name": {
			"patterns": [
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				},
				{
					"include": "#commands"
				},
				{
					"comment": "command names are allowed to start with < or >, without a backtick, but `function` requires a backtick.  See below!",
					"begin": "(?:(global|local|script|private)(`)?(:)(?=[^\\s{(,;&|)}])|(?=[^`\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}\\s{(,;&)}@#\\]]|`(?!\\s)))",
					"beginCaptures": {
						"1": {
							"name": "storage.modifier.scope.powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					},
					"end": "(?!\\G)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"comment": "at the begining of a command name, `<`, `>` or `>>` are the entire command name.",
							"match": "\\G(?:<|>>?)",
							"name": "variable.function.powershell"
						},
						{
							"begin": "\\G(?=[^\\n{(,;&|)}])",
							"end": "(?=[\\s{(,;&|)}])",
							"name": "variable.function.powershell",
							"patterns": [
								{
									"comment": "function names that start with `:` are treated differently",
									"match": "\\G(?<!:):\\p{L}\\w*[^\\s{(,;&|)}]?"
								},
								{
									"include": "#functionName"
								}
							]
						},
						{
							"begin": "(?![\\n;)}\\]])",
							"end": "$(?=\\n)|(?=[;)}\\]])",
							"patterns": [
								{
									"include": "#argument_mode"
								}
							]
						}
					]
				}
			]
		},
		"argument": {
			"patterns": [
				{
					"include": "#scriptblock"
				},
				{
					"include": "#expressionGroup"
				},
				{
					"include": "#hashtable"
				},
				{
					"include": "#array"
				},
				{
					"include": "#quotedStrings_Members"
				},
				{
					"include": "#numericConstant_argumentMode"
				},
				{
					"comment": "could be variable reference, if it doesn't have member reference, its the start of an unquoted expandable string",
					"begin": "(?=\\$(?!\\())",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"comment": "check out the first variable reference",
							"begin": "\\G(?=\\$)",
							"end": "(?!\\G)",
							"patterns": [
								{
									"include": "#variableNoProperty"
								}
							]
						},
						{
							"comment": "if a member access doesn't occur after variable, finish as an unquoted expandable string argument.",
							"begin": "(?=[^\\s{(,;&|)}])(?!(?=\\.(?!\\.)|::|\\[))",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#unquotedArgument"
								}
							]
						},
						{
							"begin": "(?=\\.(?!\\.)|::|\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								},
								{
									"comment": "attempt another argument after member access",
									"include": "#argument"
								}
							]
						}
					]
				},
				{
					"include": "#substatement"
				},
				{
					"comment": "splatting cannot have members and certain characters following, including no line comment",
					"match": "(?>@(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]))(?![~`!@#$%^*<>\\]\\\\/\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}+-])",
					"captures": {
						"0": {
							"patterns": [
								{
									"include": "#variable_inner"
								}
							]
						}
					}
				},
				{
					"include": "#unquotedArgument"
				}
			]
		},
		"argument_mode": {
			"patterns": [
				{
					"include": "#redirection"
				},
				{
					"comment": "`,` just continues current mode",
					"match": ",",
					"name": "punctuation.separator.powershell"
				},
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				},
				{
					"begin": "(?<!\\w)(--%)(?!\\w)",
					"beginCaptures": {
						"1": {
							"name": "keyword.control.powershell"
						}
					},
					"end": "$|(?=\\|)",
					"patterns": [
						{
							"match": "[^\"\\x{201C}-\\x{201E}]+?",
							"name": "string.unquoted.powershell"
						},
						{
							"begin": "(?:[\"\\x{201C}-\\x{201E}])",
							"beginCaptures": {
								"0": {
									"name": "punctuation.definition.string.begin.powershell"
								}
							},
							"end": "(?:[\"\\x{201C}-\\x{201E}])|$",
							"applyEndPatternLast": true,
							"endCaptures": {
								"0": {
									"name": "punctuation.definition.string.end.powershell"
								}
							},
							"name": "string.quoted.double.powershell"
						}
					]
				},
				{
					"match": "([\\x{2013}-\\x{2015}-]\\p{L}\\w*)(:)?",
					"captures": {
						"1": {
							"name": "entity.name.parameter.powershell"
						},
						"2": {
							"name": "punctuation.separator.parameter-value.powershell"
						}
					}
				},
				{
					"include": "#argument"
				}
			]
		},
		"unquotedArgument": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "invalid.character.escape.powershell"
				},
				{
					"match": "\\.(?=['\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}\\s{(,;&|)}$])",
					"name": "string.unquoted.argument.powershell"
				},
				{
					"begin": "(?=[^\\s{(,;&|)}])",
					"alternateBegin": "(?=[^'\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}\\s\\[{(,;&|)}$@])|(?<=\\S)(?=[$@<>])",
					"end": "(?=[\\s{(,;&|)}])",
					"contentName": "string.unquoted.argument.powershell",
					"patterns": [
						{
							"match": "\\G`[\\x{2013}-\\x{2015}-]",
							"name": "constant.character.escape.powershell"
						},
						{
							"include": "#unquotedStrings_text"
						}
					]
				}
			]
		},
		"expression_mode": {
			"comment": "Keep in mind, before begining expression mode, check for prefixed unary operators, but check for numeric constants before that!  This is done for each area that forwards to expression mode.",
			"patterns": [
				{
					"include": "#redirection"
				},
				{
					"comment": "`,` just continues current mode",
					"match": ",",
					"name": "punctuation.separator.powershell"
				},
				{
					"include": "#type"
				},
				{
					"comment": "normally operands win matches first, but numeric constant and operators share common first characters, and their matching needs to be alternated such that after any operand matches, a check for operators should occur before a numeric value is checked for again.  Operators needs to have first priority of a match after a numeric constant.",
					"include": "#operand"
				},
				{
					"comment": "Once an operator has matched, subsequently #operators_preunary should be checked first until the next non operator token is found.  However, an operator might have matched before we've even gotten here (pre-unary)",
					"include": "#operators"
				},
				{
					"ignore": "`",
					"name": "invalid.character.escape.powershell"
				},
				{
					"include": "#notCode"
				}
			]
		},
		"operand": {
			"patterns": [
				{
					"include": "#variable"
				},
				{
					"include": "#expressionGroup"
				},
				{
					"include": "#hashtable"
				},
				{
					"include": "#scriptblock"
				},
				{
					"include": "#numericConstant"
				},
				{
					"include": "#array"
				},
				{
					"include": "#substatement"
				},
				{
					"include": "#quotedStrings_Members"
				}
			]
		},
		"array": {
			"begin": "(?=@\\()",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\G(@)(\\()",
					"beginCaptures": {
						"1": {
							"name": "keyword.other.array.begin.powershell"
						},
						"2": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"name": "meta.group.array-expression.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"catchClause": {
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?i:catch)(?![^\\s{(,;&|)}])",
					"beginCaptures": {
						"0": {
							"name": "keyword.control.try-catch.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "(?={)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\G\\{",
									"beginCaptures": {
										"0": {
											"name": "punctuation.section.braces.begin.powershell"
										}
									},
									"end": "}",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.braces.end.powershell"
										}
									},
									"name": "meta.statements.try-catch.powershell",
									"patterns": [
										{
											"include": "$self"
										}
									]
								},
								{
									"begin": "(?<=})(?![,)}]|$)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#catchClause"
										}
									]
								},
								{
									"comment": "very limited what is permitted here",
									"ignore": "[^\\s{}]",
									"name": "invalid.source.powershell"
								}
							]
						},
						{
							"comment": "only [exception] arguments before the `{`",
							"begin": "\\G(?=[\\s#\\[]|<#)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?=\\[)",
									"end": "(?![\\s#\\[,]|<#)",
									"patterns": [
										{
											"match": ",",
											"name": "punctuation.separator.powershell"
										},
										{
											"include": "#type"
										},
										{
											"include": "#notCode"
										}
									]
								},
								{
									"include": "#notCode"
								}
							]
						},
						{
							"comment": "`,`, `<` and `>` not permitted here",
							"match": "[,<>]",
							"name": "invalid.source.powershell"
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "(?i:finally)(?![^\\s{(,;&|)}])",
					"beginCaptures": {
						"0": {
							"name": "keyword.control.try-finally.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"begin": "(?={)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\G\\{",
									"beginCaptures": {
										"0": {
											"name": "punctuation.section.braces.begin.powershell"
										}
									},
									"end": "}",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.braces.end.powershell"
										}
									},
									"name": "meta.statements.try-finally.powershell",
									"patterns": [
										{
											"include": "$self"
										}
									]
								},
								{
									"comment": "next statement, return when safe to exit",
									"begin": "(?<=})(?![,)}\\]])",
									"end": "(?<![}\\]])(?=\\n)|(?=[,})\\]])",
									"patterns": [
										{
											"include": "$self"
										}
									]
								},
								{
									"comment": "very limited what is permitted here",
									"ignore": "[^\\s{}]",
									"name": "invalid.source.powershell"
								}
							]
						}
					]
				},
				{
					"comment": "next statement, return when safe to exit",
					"begin": "(?![,)}\\]]|$)",
					"end": "(?<![}\\]])(?=\\n)|(?=[,})\\]])",
					"patterns": [
						{
							"include": "$self"
						}
					]
				}
			]
		},
		"commentBlock": {
			"begin": "<#",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.comment.block.begin.powershell"
				}
			},
			"end": "#>",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.comment.block.end.powershell"
				}
			},
			"name": "comment.block.powershell",
			"patterns": [
				{
					"include": "#commentEmbeddedDocs"
				}
			]
		},
		"commentLine": {
			"begin": "(#)#*",
			"captures": {
				"1": {
					"name": "punctuation.definition.comment.powershell"
				}
			},
			"end": "$(?=(\\n)?)",
			"endCaptures": {
				"1": {
					"name": "comment.line.powershell"
				}
			},
			"name": "comment.line.powershell",
			"patterns": [
				{
					"include": "#commentEmbeddedDocs"
				}
			]
		},
		"argumentModeEscapes": {
			"patterns": [
				{
					"match": "`[`0abefnrtv\"\\x{201C}-\\x{201E}'\\x{2018}-\\x{201B}$@#{(,;&|)}<>\\n]",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"attribute": {
			"patterns": [
				{
					"begin": "(?i)(?:(?:cmdletbinding|alias|flags|outputtype|parameter|validate(?:not(?:null(?:orempty)?)|count|set|script|range|pattern|length)|allow(?:null|empty(?:collection|string))|supportswildcards|dsc(?:resource|property))(?=\\())",
					"beginCaptures": {
						"0": {
							"name": "support.function.attribute.powershell"
						}
					},
					"end": "(?!\\G\\()",
					"name": "meta.attribute.powershell",
					"patterns": [
						{
							"begin": "\\(",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.group.begin.powershell"
								}
							},
							"end": "\\)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.group.end.powershell"
								}
							},
							"patterns": [
								{
									"comment": "`key` for DscProperty attribute",
									"begin": "(?i)\\b(mandatory|valuefrom(?:pipeline(?:bypropertyname)?|remainingarguments)|position(?:albinding)?|(?:default)?parametersetname|supports(?:shouldprocess|paging|transactions)|help(?:uri|message)|confirmimpact|ignorecase|key)\\b",
									"beginCaptures": {
										"1": {
											"name": "variable.parameter.attribute.powershell"
										}
									},
									"end": "$(?=\\n)|(?=[,;&|)}\\]])",
									"patterns": [
										{
											"begin": "=",
											"beginCaptures": {
												"0": {
													"name": "keyword.operator.assignment.powershell"
												}
											},
											"end": "$(?=\\n)|(?=[,;&|)}\\]])",
											"patterns": [
												{
													"include": "#advanceToToken"
												},
												{
													"comment": "begin at the first token in the expression, to test for numeric and unary operators",
													"begin": "(?!$|[;|)}\\]])",
													"end": "(?=.|$)",
													"applyEndPatternLast": true,
													"patterns": [
														{
															"comment": "allow for possibility that numeric value or unary operators match first, before resuming in expression mode",
															"begin": "(?!\\G)(?!$(?=\\n)|[,;&|)}\\]])",
															"end": "$(?=\\n)|(?=[,;&|)}\\]])",
															"patterns": [
																{
																	"include": "#expression_mode"
																}
															]
														},
														{
															"include": "#numericConstant"
														},
														{
															"include": "#operators_preUnary"
														},
														{
															"comment": "if neither numeric or a pre-unary operator, just finish in expression mode",
															"begin": "(?!$(?=\\n)|[;&|)}\\]])",
															"end": "$(?=\\n)|(?=[;&|)}\\]])",
															"patterns": [
																{
																	"include": "#expression_mode"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"include": "#expression_mode"
								}
							]
						}
					]
				},
				{
					"match": "(?<![.\\w-])(?i:ordered)(?![.\\w+`\\[-])",
					"name": "support.function.attribute.powershell"
				},
				{
					"match": "(?<![.\\w-])(?i:ref)(?![.\\w+`\\[-])",
					"name": "storage.modifier.powershell"
				}
			]
		},
		"commands": {
			"patterns": [
				{
					"comment": "Verb-Noun pattern:",
					"begin": "(?i:Add|Approve|Assert|Backup|Block|Build|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Deploy|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Mount|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Write)-(?:`.|[^\\s{(,;&)}])+?(?:\\.(?i:exe|cmd|bat|ps1))?(?=[\\s{(,;&)}])",
					"beginCaptures": {
						"0": {
							"name": "support.function.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;&)}\\]])",
					"patterns": [
						{
							"include": "#argument_mode"
						}
					]
				},
				{
					"comment": "Builtin cmdlets with reserved verbs, trailing negative lookahead needs work",
					"begin": "(?i:(?:foreach|where|sort|tee)-object)(?=[\\s{(,;&)}])",
					"beginCaptures": {
						"0": {
							"name": "support.function.$0.powershell"
						}
					},
					"end": "$(?=\\n)|(?=[;&)}\\]])",
					"patterns": [
						{
							"include": "#argument_mode"
						}
					]
				}
			]
		},
		"commentEmbeddedDocs": {
			"patterns": [
				{
					"captures": {
						"1": {
							"name": "constant.string.documentation.powershell"
						},
						"2": {
							"name": "keyword.operator.documentation.powershell"
						}
					},
					"match": "(?:^|\\G)(?i:\\s*(\\.)(COMPONENT|DESCRIPTION|EXAMPLE|FUNCTIONALITY|INPUTS|LINK|NOTES|OUTPUTS|ROLE|SYNOPSIS))(?:\\s*$)",
					"name": "comment.documentation.embedded.powershell"
				},
				{
					"captures": {
						"1": {
							"name": "constant.string.documentation.powershell"
						},
						"2": {
							"name": "keyword.operator.documentation.powershell"
						},
						"3": {
							"name": "keyword.operator.documentation.powershell"
						}
					},
					"match": "(?:^|\\G)(?i:\\s*(\\.)(PARAMETER|FORWARDHELP(?:CATEGORY|TARGETNAME)|REMOTEHELPRUNSPACE|EXTERNALHELP)\\s+([\\w-]+))",
					"name": "comment.documentation.embedded.powershell"
				}
			]
		},
		"unicodeEscape": {
			"comment": "`u{xxxx} added in PowerShell 6.0",
			"patterns": [
				{
					"match": "`u\\{(?:(?:10)?([0-9a-fA-F]){,4}|0?\\g<1>{1,5})}",
					"name": "constant.character.escape.powershell"
				},
				{
					"match": "`u(?:\\{[0-9a-fA-F]{,6}.)?",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"doubleQuotedStringEscapes": {
			"patterns": [
				{
					"match": "`[`0abefnrtv\"\\x{201C}-\\x{201E}$]",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				},
				{
					"match": "(?:[\"\\x{201C}-\\x{201E}]){2}",
					"name": "constant.character.escape.powershell"
				}
			]
		},
		"doubleQuotedHereStringEscapes": {
			"patterns": [
				{
					"match": "`[`0abefnrtv]|^`[\"\\x{201C}-\\x{201E}](?=@)",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				}
			]
		},
		"declarationParameterSet": {
			"begin": "\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.group.begin.powershell"
				}
			},
			"name": "meta.parameters.powershell",
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.group.end.powershell"
				}
			},
			"patterns": [
				{
					"begin": "=",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.assignment.parameter-default.powershell"
						}
					},
					"end": "(?=[,)])|(?=\\n)(?!\\G)",
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"comment": "begin at the first token in the expression, to test for numeric and unary operators",
							"begin": "(?!$|[;&|)}\\]])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"comment": "allow for possibility that numeric value or unary operators match first, before resuming in expression mode",
									"begin": "(?!\\G)(?!$(?=\\n)|[,;&|)}\\]])",
									"end": "$(?=\\n)|(?=[,;&|)}\\]])",
									"patterns": [
										{
											"include": "#expression_mode"
										}
									]
								},
								{
									"include": "#numericConstant"
								},
								{
									"include": "#operators_preUnary"
								},
								{
									"comment": "if neither numeric or a pre-unary operator, just finish in expression mode",
									"begin": "(?!$(?=\\n)|[;&)}\\]])",
									"end": "$(?=\\n)|(?=[;&)}\\]])",
									"patterns": [
										{
											"include": "#expression_mode"
										}
									]
								}
							]
						}
					]
				},
				{
					"match": ",",
					"name": "punctuation.separator.comma.powershell"
				},
				{
					"include": "#variableNoProperty"
				},
				{
					"include": "#type"
				},
				{
					"include": "#notCode"
				}
			]
		},
		"expressionGroup": {
			"begin": "(?=\\()",
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\(",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.group.subexpression.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"ifPattern": {
			"patterns": [
				{
					"include": "#advanceToToken"
				},
				{
					"begin": "(?=\\()",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\G\\(",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.group.begin.powershell"
								}
							},
							"end": "\\)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.group.end.powershell"
								}
							},
							"name": "meta.if-condition.powershell",
							"patterns": [
								{
									"comment": "`;` not permitted here",
									"match": ";",
									"name": "invalid.source.powershell"
								},
								{
									"include": "#command_mode"
								}
							]
						},
						{
							"begin": "(?<=\\))(?![,)}])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?={)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"begin": "\\G\\{",
											"beginCaptures": {
												"0": {
													"name": "punctuation.section.braces.begin.powershell"
												}
											},
											"end": "}",
											"endCaptures": {
												"0": {
													"name": "punctuation.section.braces.end.powershell"
												}
											},
											"name": "meta.statements.if-condition.powershell",
											"patterns": [
												{
													"include": "$self"
												}
											]
										},
										{
											"begin": "(?<=})(?![,)}])",
											"end": "(?=.|$)",
											"applyEndPatternLast": true,
											"patterns": [
												{
													"include": "#advanceToToken"
												},
												{
													"begin": "(?i:else)(?![^\\s{(,;&|)}])",
													"beginCaptures": {
														"0": {
															"name": "keyword.control.if-else.powershell"
														}
													},
													"end": "(?=.|$)",
													"applyEndPatternLast": true,
													"patterns": [
														{
															"include": "#advanceToToken"
														},
														{
															"begin": "{",
															"beginCaptures": {
																"0": {
																	"name": "punctuation.section.braces.begin.powershell"
																}
															},
															"end": "}",
															"endCaptures": {
																"0": {
																	"name": "punctuation.section.braces.end.powershell"
																}
															},
															"name": "meta.statements.if-else-condition.powershell",
															"patterns": [
																{
																	"include": "$self"
																}
															]
														},
														{
															"comment": "next statement, return when safe to exit",
															"begin": "(?<=})(?![,)}\\]])",
															"end": "(?<![}\\)])(?=\\n)|(?=[,})\\]])",
															"applyEndPatternLast": false,
															"patterns": [
																{
																	"include": "$self"
																}
															]
														},
														{
															"comment": "very limited what is permitted here",
															"ignore": "[^\\s{}]",
															"name": "invalid.source.powershell"
														}
													]
												},
												{
													"begin": "(?i:elseif)(?![^\\s{(,;&|)}])",
													"beginCaptures": {
														"0": {
															"name": "keyword.control.if-elseif.powershell"
														}
													},
													"end": "(?=.|$)",
													"applyEndPatternLast": true,
													"patterns": [
														{
															"include": "#ifPattern"
														}
													]
												},
												{
													"comment": "next statement, return when safe to exit",
													"begin": "(?<=[}\\)])(?![,)}\\]])",
													"end": "(?<![}\\)])(?=\\n)|(?=[,})\\]])",
													"applyEndPatternLast": false,
													"patterns": [
														{
															"include": "$self"
														}
													]
												}
											]
										}
									]
								},
								{
									"comment": "very limited what is permitted here",
									"ignore": "[^\\s{()}]",
									"name": "invalid.source.powershell"
								}
							]
						},
						{
							"comment": "very limited what is permitted here",
							"ignore": "[^\\s{]",
							"name": "invalid.source.powershell"
						}
					]
				},
				{
					"comment": "`,`, `<` and `>` not permitted here",
					"ignore": "[,<>]",
					"name": "invalid.source.powershell"
				},
				{
					"ignore": "#notCode"
				}
			]
		},
		"substatement": {
			"begin": "(?=\\$\\()",
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(\\$)(\\()",
					"beginCaptures": {
						"1": {
							"name": "keyword.other.substatement.powershell"
						},
						"2": {
							"name": "punctuation.section.group.begin.powershell"
						}
					},
					"name": "meta.group.substatement-expression.powershell",
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.group.end.powershell"
						}
					},
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"substatementNoProperty": {
			"begin": "(\\$)(\\()",
			"beginCaptures": {
				"1": {
					"name": "keyword.other.substatement.powershell"
				},
				"2": {
					"name": "punctuation.section.group.begin.powershell"
				}
			},
			"name": "meta.embedded.substatement.powershell",
			"contentName": "interpolated.complex.source.powershell",
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.group.end.powershell"
				}
			},
			"patterns": [
				{
					"include": "$self"
				}
			]
		},
		"numericConstant": {
			"patterns": [
				{
					"beginCaptures": {
						"1": {
							"name": "constant.numeric.integer.powershell"
						},
						"2": {
							"name": "storage.modifier.long.powershell"
						},
						"4": {
							"name": "storage.modifier.long.powershell"
						},
						"5": {
							"name": "constant.language.powershell"
						}
					},
					"begin": "(?>([+\\x{2013}-\\x{2015}-]?(?:[0-9]+(?i:(?![ed]|\\.(?!\\.))(l)?|(?:\\.[0-9]*)?((?:(?i:e)[+\\x{2013}-\\x{2015}-]?[0-9]+)?(l)))|(?:\\.[0-9]+)\\g<3>))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}<>.!+%*/=\\x{2013}-\\x{2015}-])",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#numeric_post"
						}
					]
				},
				{
					"beginCaptures": {
						"1": {
							"name": "constant.numeric.hex.powershell"
						},
						"2": {
							"name": "storage.modifier.long.powershell"
						},
						"3": {
							"name": "constant.language.powershell"
						}
					},
					"begin": "(?>([+\\x{2013}-\\x{2015}-]?0(?i:x[0-9a-f_]+(l)?))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}<>.!+%*/=\\x{2013}-\\x{2015}-])",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#numeric_post"
						}
					]
				},
				{
					"beginCaptures": {
						"1": {
							"name": "constant.numeric.decimal.powershell"
						},
						"2": {
							"name": "storage.modifier.decimal.powershell"
						},
						"3": {
							"name": "constant.language.powershell"
						}
					},
					"begin": "(?>([+\\x{2013}-\\x{2015}-]?(?:(?:[0-9]+)|(?=\\.[0-9]))(?:\\.[0-9]*)?(?i:(?:e[+\\x{2013}-\\x{2015}-]?[0-9]+)?(?!l)(d)?))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}\\]<>.!+%*/=\\x{2013}-\\x{2015}-])",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#numeric_post"
						}
					]
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.binary.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"comment": "(?>(?:(?<!\\w)|\\G)([+\\x{2013}-\\x{2015}-]?0(?i:b[01_]+l?))((?i:[kmgtp]b)?))(?![^\\s#{(,;|)}<>.!+%*/=\\x{2013}-\\x{2015}-])"
				}
			],
			"repository": {
				"numeric_post": {
					"patterns": [
						{
							"begin": "\\G(?=\\.(?!\\.)|::|\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						},
						{
							"begin": "\\G(?=[\\s.+\\x{2013}-\\x{2015}-]|<#|`\\n)(?![\\x{2013}-\\x{2015}-]\\p{L}|\\n)",
							"end": "\\.\\.|\\+\\+?|[\\x{2013}-\\x{2015}-](?!\\p{L})[\\x{2013}-\\x{2015}-]?|$(?=\\n)|(?![\\s]|<#|`\\n|$)",
							"endCaptures": {
								"0": {
									"patterns": [
										{
											"include": "#operators"
										}
									]
								}
							},
							"patterns": [
								{
									"match": "`\\n",
									"name": "constant.character.escape.powershell"
								},
								{
									"include": "#commentBlock"
								}
							]
						}
					]
				}
			}
		},
		"numericConstant_argumentMode": {
			"patterns": [
				{
					"captures": {
						"1": {
							"name": "constant.numeric.integer.powershell"
						},
						"2": {
							"name": "storage.modifier.long.powershell"
						},
						"4": {
							"name": "storage.modifier.long.powershell"
						},
						"5": {
							"name": "constant.language.powershell"
						}
					},
					"match": "(?>((?:[0-9]+(?i:(?![ed]|\\.(?!\\.))(l)?|(?:\\.[0-9]*)?((?:(?i:e)[+\\x{2013}-\\x{2015}-]?[0-9]+)?(l)))|(?:\\.[0-9]+)\\g<2>)))((?i:[kmgtp]b)?)(?![^\\s{(,;|)}])"
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.hex.powershell"
						},
						"2": {
							"name": "storage.modifier.long.powershell"
						},
						"3": {
							"name": "constant.language.powershell"
						}
					},
					"match": "(?>(0(?i:x[0-9a-f_]+(l)?))((?i:[kmgtp]b)?))(?![^\\s{(,;|)}])"
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.decimal.powershell"
						},
						"2": {
							"name": "storage.modifier.decimal.powershell"
						},
						"3": {
							"name": "constant.language.powershell"
						}
					},
					"match": "(?>((?:(?:[0-9]+)|(?=\\.[0-9]))(?:\\.[0-9]*)?(?i:(?:e[+\\x{2013}-\\x{2015}-]?[0-9]+)?(?!l)(d)?))((?i:[kmgtp]b)?))(?![^\\s{(,;|)}])"
				},
				{
					"captures": {
						"1": {
							"name": "constant.numeric.binary.powershell"
						},
						"2": {
							"name": "constant.language.powershell"
						}
					},
					"comment": "(?>(?:(?<!\\w)|\\G)([+\\x{2013}-\\x{2015}-]?0(?i:b[01_]+l?))((?i:[kmgtp]b)?))(?![^\\s{(,;|)}])"
				}
			]
		},
		"scriptblock": {
			"begin": "(?={)",
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.scriptblock.powershell",
					"patterns": [
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"type": {
			"comment": "This is used by both type and attribute references.",
			"begin": "(?=\\[)",
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\G\\[",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.bracket.begin.powershell"
						}
					},
					"end": "]|(?=\\n)",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.bracket.end.powershell"
						}
					},
					"applyEndPatternLast": true,
					"name": "meta.attribute-or-type-reference.powershell",
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"ignore include": "#attribute",
							"match": "(?i)(?:(?:cmdletbinding|alias|flags|outputtype|parameter|validate(?:not(?:null(?:orempty)?)|count|set|script|range|pattern|length)|allow(?:null|empty(?:collection|string))|supportswildcards|dsc(?:resource|property))(?![.\\w+`-]))",
							"name": "support.function.attribute.powershell"
						},
						{
							"begin": "(?=\\()",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\G\\(",
									"beginCaptures": {
										"0": {
											"name": "punctuation.group.attribute-argument-set.begin.powershell"
										}
									},
									"end": "\\)",
									"endCaptures": {
										"0": {
											"name": "punctuation..group.attribute-argument-set.end.powershell"
										}
									},
									"applyEndPatternLast": true,
									"name": "meta.attribute-argument-set.powershell",
									"patterns": [
										{
											"begin": "\\b([\\p{L}_]\\w*)",
											"beginCaptures": {
												"1": {
													"name": "variable.parameter.attribute.powershell"
												}
											},
											"end": "$(?=\\n)|(?=[,;&|)}\\]])",
											"patterns": [
												{
													"begin": "=",
													"beginCaptures": {
														"0": {
															"name": "keyword.operator.assignment.attribute-argument.powershell"
														}
													},
													"end": "$(?=\\n)|(?=[,;&|)}\\]])",
													"patterns": [
														{
															"include": "#advanceToToken"
														},
														{
															"comment": "begin at the first token in the expression, to test for numeric and unary operators",
															"begin": "(?!$|[;|)}\\]])",
															"end": "(?=.|$)",
															"applyEndPatternLast": true,
															"patterns": [
																{
																	"comment": "allow for possibility that numeric value or unary operators match first, before resuming in expression mode",
																	"begin": "(?!\\G)(?!$(?=\\n)|[,;&|)}\\]])",
																	"end": "$(?=\\n)|(?=[,;&|)}\\]])",
																	"patterns": [
																		{
																			"include": "#expression_mode"
																		}
																	]
																},
																{
																	"include": "#numericConstant"
																},
																{
																	"include": "#operators_preUnary"
																},
																{
																	"comment": "if neither numeric or a pre-unary operator, just finish in expression mode",
																	"begin": "(?!$(?=\\n)|[;&|)}\\]])",
																	"end": "$(?=\\n)|(?=[;&|)}\\]])",
																	"patterns": [
																		{
																			"include": "#expression_mode"
																		}
																	]
																}
															]
														}
													]
												},
												{
													"include": "#notCode"
												}
											]
										},
										{
											"match": "=",
											"name": "invalid.source.powershell"
										},
										{
											"include": "#expression_mode"
										}
									]
								},
								{
									"begin": "(?<=\\))(?![;&|)}\\]])",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#advanceToToken"
										}
									]
								}
							]
						},
						{
							"include": "#type_SubType"
						}
					]
				},
				{
					"comment": "index access is not permitted here",
					"begin": "(?=\\.(?!\\.)|::)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.bracket.end.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						},
						{
							"begin": "(?!\\G)(?!$(?=\\n)|(?=[;)}\\]]))",
							"end": "$(?=\\n)|(?=[;)}\\]])",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						}
					]
				}
			]
		},
		"type_Disolve": {
			"patterns": [
				{
					"include": "#type_keywords"
				},
				{
					"match": "[^\\.+]+",
					"name": "storage.type.powershell"
				},
				{
					"match": "\\.",
					"name": "punctuation.accessor.type.powershell.powershell"
				},
				{
					"match": "\\+",
					"name": "keyword.operator.type.powershell"
				}
			]
		},
		"type_SubType": {
			"patterns": [
				{
					"begin": "(\\[)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.bracket.begin.powershell"
						}
					},
					"end": "(])|(?>[^\\s\\p{L},])",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.bracket.end.powershell"
						}
					},
					"applyEndPatternLast": true,
					"name": "meta.type-reference.powershell",
					"patterns": [
						{
							"include": "#type_SubType"
						},
						{
							"match": ",",
							"name": "punctuation.separator.comma.powershell"
						},
						{
							"match": "[^\\s\\[\\]+,]+",
							"name": "invalid.character.powershell"
						}
					]
				},
				{
					"begin": "(?!`)([\\p{L}_`][\\w`+]*(?:\\.\\g<1>?)?)",
					"beginCaptures": {
						"0": {
							"patterns": [
								{
									"include": "#type_Disolve"
								}
							]
						}
					},
					"end": "(?=[^\\s]|\\n)|(?<=])",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"match": "((?i:Version|Culture|PublicKeyToken))(=)([^,\\[\\]]*)",
							"captures": {
								"1": {
									"name": "variable.parameter.attribute.powershell"
								},
								"2": {
									"name": "keyword.operator.assignment.powershell"
								},
								"3": {
									"name": "constant.character.powershell"
								}
							},
							"name": "invalid.character.powershell"
						},
						{
							"include": "#type_SubType"
						},
						{
							"match": ",",
							"name": "punctuation.separator.comma.powershell"
						},
						{
							"match": "(?<!])[^\\s\\[\\]\\(+,]+",
							"name": "invalid.character.powershell"
						}
					]
				},
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				}
			]
		},
		"type_keywords": {
			"comment": "primitive types and base classes often used",
			"patterns": [
				{
					"comment:": "[short], [ushort], [uint], [ulong] added PowerShell Core 6.2;",
					"match": "(?<![.\\w-])(?i:(?:value)?type|void|switch|(?:ps(?:custom)?)?object|pscredential|psmoduleinfo|hashtable|scriptblock|string|single|float|double|decimal|s?byte|bool(?:ean)?|char|datetime|array|bigint|u?int(?:32|16|64)?|u?long|u?short)(?![.\\w+`-])",
					"name": "keyword.type.powershell"
				},
				{
					"match": "(?<![.\\w-])(?i:system|math|text|convert|regex|xml|enum)(?![\\w-])",
					"name": "support.class.powershell"
				}
			]
		},
		"advanceToArgument": {
			"comment": "consume spaces and comments (but not unescaped line ends) until the next token appears",
			"begin": "\\G(?=[\\s]|<#|`\\s)",
			"end": "(?!\\s)(?!$)|$(?=\\n)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"match": "`\\n",
					"name": "constant.character.escape.powershell"
				},
				{
					"comment": "useless escape, and doesn't count as a token",
					"match": "`\\s",
					"name": "invalid.character.escape.powershell"
				},
				{
					"include": "#commentBlock"
				}
			]
		},
		"advanceToToken": {
			"comment": "consume spaces and comments and line ends until the next token appears",
			"begin": "\\G(?=[\\s#]|<#|`\\s)",
			"end": "(?!\\s)(?!$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"match": "`\\n",
					"name": "constant.character.escape.powershell"
				},
				{
					"comment": "useless escape, and doesn't count as a token",
					"match": "`\\s",
					"name": "invalid.character.escape.powershell"
				},
				{
					"include": "#commentLine"
				},
				{
					"include": "#commentBlock"
				}
			]
		},
		"accessors": {
			"patterns": [
				{
					"begin": "\\G(?:\\.(?!\\.)|(?<!:)::)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.accessor.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#members"
						},
						{
							"include": "#commentLine"
						},
						{
							"include": "#commentBlock"
						},
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "\\G(?=\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"begin": "\\[",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.bracket.begin.powershell"
								}
							},
							"end": "]|(?!\\G)$(?=\\n)",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.bracket.end.powershell"
								}
							},
							"name": "meta.index.powershell",
							"patterns": [
								{
									"include": "#expression_mode"
								}
							]
						},
						{
							"begin": "(?=\\.(?!\\.)|::|\\[)",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						}
					]
				},
				{
					"include": "#commentLine"
				},
				{
					"include": "#commentBlock"
				}
			]
		},
		"members": {
			"patterns": [
				{
					"begin": "(?<![\\])])(?:(?i:(foreach|where)(?=[\\({]))|([\\p{L}_]\\w*(?=\\()))",
					"captures": {
						"1": {
							"name": "support.function.$1.powershell"
						},
						"2": {
							"name": "variable.function.method.powershell"
						}
					},
					"end": "(?!\\G)|(?=\\))",
					"patterns": [
						{
							"begin": "\\G(?=\\()",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"begin": "\\(",
									"beginCaptures": {
										"0": {
											"name": "punctuation.section.method-arguments.begin.powershell"
										}
									},
									"contentName": "meta.method-arguments.powershell",
									"end": "\\)",
									"endCaptures": {
										"0": {
											"name": "punctuation.section.method-arguments.end.powershell"
										}
									},
									"patterns": [
										{
											"include": "#expression_mode"
										}
									]
								},
								{
									"begin": "(?=\\.(?!\\.)|::|\\[)",
									"end": "(?=.|$)",
									"applyEndPatternLast": true,
									"patterns": [
										{
											"include": "#accessors"
										}
									]
								}
							]
						},
						{
							"begin": "\\G(?=\\{)",
							"end": "(?!\\G)",
							"patterns": [
								{
									"include": "#scriptblock"
								}
							]
						}
					]
				},
				{
					"begin": "(?<![\\])])[\\p{L}_]\\w*(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"beginCaptures": {
						"0": {
							"name": "variable.other.object.property.powershell"
						}
					},
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				},
				{
					"match": "(?<![\\])])[\\p{L}_]\\w*",
					"name": "variable.other.property.powershell"
				},
				{
					"comment": "need to wrap a begin block around this using \\G",
					"include": "#quotedStrings_Members"
				}
			]
		},
		"switchConditions": {
			"begin": "(?={)",
			"end": "(?=.|$)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "\\G\\{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.switch-conditions.powershell",
					"patterns": [
						{
							"begin": "(?:\\G|(?<=\\}))(?![,;&|)}])",
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#advanceToToken"
								},
								{
									"begin": "(?<=[\\s>]|\\G|^)(?![\\s#,;&|)}<>]|<#)",
									"end": "(?!\\G)",
									"name": "meta.argument.switch-condition.powershell",
									"patterns": [
										{
											"comment": "default: only in switch",
											"match": "(?i:default)(?![^\\s{(,;&|)}])",
											"name": "keyword.control.switch-default.powershell"
										},
										{
											"include": "#argument"
										}
									]
								}
							]
						},
						{
							"begin": "{",
							"beginCaptures": {
								"0": {
									"name": "punctuation.section.braces.begin.powershell"
								}
							},
							"end": "}",
							"endCaptures": {
								"0": {
									"name": "punctuation.section.braces.end.powershell"
								}
							},
							"name": "meta.statements.switch-condition.powershell",
							"patterns": [
								{
									"include": "$self"
								}
							]
						},
						{
							"include": "#notCode"
						},
						{
							"comment": "very limited what is permitted here",
							"match": "[^\\s{()}]",
							"name": "invalid.source.powershell"
						}
					]
				},
				{
					"comment": "next statement, return when safe to exit",
					"begin": "(?<=})(?![,)}\\]])",
					"end": "(?<!})(?=\\n)|(?=[,})\\]])",
					"applyEndPatternLast": false,
					"patterns": [
						{
							"include": "$self"
						}
					]
				}
			]
		},
		"variable_inner": {
			"comment": "separate the parts of the variable name and scope them",
			"patterns": [
				{
					"match": "[$@][^:]*:$",
					"name": "invalid.character.variable.powershell"
				},
				{
					"captures": {
						"1": {
							"name": "constant.language.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"comment": "These are special constants.",
					"match": "(([$@])(?i:(:?(?:False|Null|True)))$)"
				},
				{
					"captures": {
						"1": {
							"name": "variable.language.builtin.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"comment": "These are the other built-in constants.",
					"match": "(([$@])(?i:(:?(?:Error|ExecutionContext|Is(?:CoreCLR|Linux|MacOS|Windows)|Host|Home|PID|PsHome|PsVersionTable|ShellID)$)))"
				},
				{
					"captures": {
						"1": {
							"name": "variable.language.builtin.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"match": "(([$@])(?i:((?:[$^?])|:\\?|:?(?:_|Args|ConsoleFileName|Event|EventArgs|EventSubscriber|ForEach|Input|LastExitCode|Matches|MyInvocation|NestedPromptLevel|Profile|PSBoundParameters|PsCmdlet|PsCulture|PSDebugContext|PSItem|PSCommandPath|PSScriptRoot|PsUICulture|Pwd|Sender|SourceArgs|SourceEventArgs|StackTrace|Switch|This)$)))"
				},
				{
					"captures": {
						"1": {
							"name": "variable.language.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.powershell"
						}
					},
					"comment": "Style preference variables as language variables so that they stand out.",
					"match": "(([$@])(?i:(:?(?:ConfirmPreference|DebugPreference|ErrorActionPreference|ErrorView|FormatEnumerationLimit|MaximumAliasCount|MaximumDriveCount|MaximumErrorCount|MaximumFunctionCount|MaximumHistoryCount|MaximumVariableCount|OFS|OutputEncoding|ProgressPreference|PsCulture|PSDebugContext|PSDefaultParameterValues|PSEmailServer|PSItem|PSModuleAutoloadingPreference|PSSenderInfo|PSSessionApplicationName|PSSessionConfigurationName|PSSessionOption|VerbosePreference|WarningPreference|WhatIfPreference)$)))"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.variable.powershell"
						},
						"2": {
							"patterns": [
								{
									"include": "#variable_scopeOrDrive"
								}
							]
						}
					},
					"match": "(?:([$@])(?:(?>([\\w][\\w?]*:(?!:)|:))?([\\w](?:[\\w?]|(?<!:):(?!:))*|[$^:])))",
					"name": "variable.other.readwrite.powershell"
				}
			]
		},
		"variable_scopeOrDrive": {
			"patterns": [
				{
					"match": "((?i:global|local|private|script|using|workflow))(`)?(:)",
					"captures": {
						"1": {
							"name": "storage.modifier.scope.powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					}
				},
				{
					"match": "(?i:(Alias|Cert|Env|Function|HKCU|HKLM|Variable|WSMan))(`)?(:)",
					"captures": {
						"1": {
							"name": "keyword.type.drive:powershell"
						},
						"2": {
							"name": "invalid.character.escape.powershell"
						},
						"3": {
							"name": "punctuation.separator.colon.powershell"
						}
					}
				},
				{
					"comment": "Unknown drive",
					"begin": "(?=.)",
					"end": ":",
					"endCaptures": {
						"0": {
							"name": "punctuation.separator.colon.powershell"
						}
					},
					"name": "storage.type.drive.powershell",
					"patterns": [
						{
							"match": "`(?:[`0abefnrtv{}\\n])",
							"name": "constant.character.escape.powershell"
						},
						{
							"include": "#unicodeEscape"
						}
					]
				}
			]
		},
		"variable_bracketed": {
			"begin": "(?=\\$\\{)",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(\\$)(\\{)",
					"beginCaptures": {
						"1": {
							"name": "punctuation.definition.variable.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.variable.braces.end.powershell"
						}
					},
					"name": "variable.other.readwrite.powershell",
					"patterns": [
						{
							"include": "#variable_bracketed_inside"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"variable_bracketed_inside": {
			"patterns": [
				{
					"comment": "capture a complete variable reference that appears on a single line and attempt to scope language variables"
				},
				{
					"comment": "this captures up to the first colon, and then matches up the capture",
					"match": "\\G(?:(?:[^`{}:]|`[`{}]?+)+:|:)",
					"captures": {
						"0": {
							"patterns": [
								{
									"include": "#variable_scopeOrDrive"
								}
							]
						}
					}
				},
				{
					"match": "`(?:[`0abefnrtv{}\\n])",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#unicodeEscape"
				},
				{
					"match": "`",
					"name": "invalid.character.escape.powershell"
				},
				{
					"match": "{",
					"name": "invalid.character.powershell"
				}
			]
		},
		"variableNoProperty_bracketed": {
			"begin": "(?=\\$\\{)",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(\\$)(\\{)",
					"beginCaptures": {
						"1": {
							"name": "punctuation.definition.variable.powershell"
						},
						"2": {
							"name": "punctuation.definition.variable.braces.begin.powershell"
						}
					},
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.variable.braces.end.powershell"
						}
					},
					"name": "variable.other.readwrite.powershell",
					"patterns": [
						{
							"include": "#variable_bracketed_inside"
						}
					]
				}
			]
		},
		"variable": {
			"patterns": [
				{
					"begin": "(?=\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]|\\{))",
					"end": "(?!\\G)",
					"applyEndPatternLast": false,
					"patterns": [
						{
							"begin": "\\G\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:])(?=\\.(?!\\.)|::|\\[)",
							"beginCaptures": {
								"0": {
									"patterns": [
										{
											"include": "#variable_inner"
										}
									]
								}
							},
							"end": "(?=.|$)",
							"applyEndPatternLast": true,
							"patterns": [
								{
									"include": "#accessors"
								}
							]
						},
						{
							"match": "\\G\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:])",
							"captures": {
								"0": {
									"patterns": [
										{
											"include": "#variable_inner"
										}
									]
								}
							}
						},
						{
							"include": "#variable_bracketed"
						}
					]
				},
				{
					"comment": "splatting cannot have members and certain characters following, including no line comment",
					"match": "(?>@(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]))",
					"name": "invalid.splat.powershell"
				}
			]
		},
		"variableNoProperty": {
			"begin": "(?=\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:]|\\{))",
			"end": "(?!\\G)",
			"applyEndPatternLast": false,
			"patterns": [
				{
					"match": "\\G\\$(?:(?>[\\w][\\w?]*:(?!:)|:)?(?:[\\w?](?:[\\w?]|:(?!:))*|:(?!:))|[$^:])",
					"captures": {
						"0": {
							"patterns": [
								{
									"include": "#variable_inner"
								}
							]
						}
					}
				},
				{
					"include": "#variableNoProperty_bracketed"
				}
			],
			"name": "meta.embedded.interpolated.powershell"
		},
		"RequiresDirective": {
			"comment": "requires directive must be on single line, so capture and tokenize, current PS <= 6.2 allow `requires` keyword without delimiter, but the parameters must follow with a delimiter!",
			"oldbegin": "^\\s*(#)((?i:requires))(?![^\\s{(,;&|)}])",
			"match": "^\\s*(#)((?i:requires))(.?)(.*)$",
			"captures": {
				"1": {
					"name": "punctuation.definition.comment.powershell"
				},
				"2": {
					"name": "keyword.control.requires.powershell"
				},
				"3": {
					"patterns": [
						{
							"match": "\\S",
							"name": "invalid.source.powershell"
						}
					]
				},
				"4": {
					"patterns": [
						{
							"match": "([\\x{2013}-\\x{2015}-](?i:Modules|PSSnapin|PSEdition|RunAsAdministrator|ShellId|Version)\\b)(:)?",
							"captures": {
								"1": {
									"name": "entity.name.parameter.powershell"
								},
								"2": {
									"name": "punctuation.separator.parameter-value.powershell"
								}
							}
						},
						{
							"comment": "needs custom argument handler, single line quoted or unquoted arguments",
							"match": "(?<!\\x{2013}-\\x{2015}-)\\b\\p{L}+|\\d+(?:\\.\\d+)*",
							"name": "variable.parameter.powershell"
						},
						{
							"match": ",",
							"name": "punctuation.separator.powershell"
						},
						{
							"comment": "needs custom hashtable that does not auto continue to next line",
							"include": "#hashtable"
						},
						{
							"include": "#notCode"
						}
					]
				}
			},
			"oldend": "$",
			"name": "comment.line.powershell meta.requires.powershell"
		},
		"hashtable": {
			"begin": "(?=@\\{)",
			"end": "(?!.\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"begin": "(@)(\\{)",
					"beginCaptures": {
						"1": {
							"name": "keyword.other.hashtable.begin.powershell"
						},
						"2": {
							"name": "punctuation.section.braces.begin.powershell"
						}
					},
					"end": "\\}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.braces.end.powershell"
						}
					},
					"name": "meta.hashtable.powershell",
					"patterns": [
						{
							"match": "\\b([\\p{L}_]\\w*)(?=\\s*=)",
							"name": "entity.name.variable.property.powershell"
						},
						{
							"include": "#type"
						},
						{
							"include": "#variable"
						},
						{
							"include": "#quotedStrings_Members"
						},
						{
							"begin": "=",
							"beginCaptures": {
								"0": {
									"name": "keyword.operator.assignment.hashtable-member.powershell"
								}
							},
							"end": "(?=[;}\\n])",
							"patterns": [
								{
									"include": "#command_mode"
								}
							]
						},
						{
							"include": "#terminators"
						},
						{
							"include": "#notCode"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"quotedStrings_Members": {
			"comment": "detect all quoted strings (arguments or expressions) starting here",
			"begin": "(?=@?['\\x{2018}-\\x{201B}\"\\x{201C}-\\x{201E}])",
			"end": "(?!\\G)",
			"applyEndPatternLast": true,
			"patterns": [
				{
					"comment": "single quoted strings",
					"begin": "\\G['\\x{2018}-\\x{201B}]",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.powershell"
						}
					},
					"end": "['\\x{2018}-\\x{201B}]",
					"applyEndPatternLast": true,
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.powershell"
						}
					},
					"name": "string.quoted.single.powershell",
					"patterns": [
						{
							"match": "['\\x{2018}-\\x{201B}]{2}",
							"name": "constant.character.escape.powershell"
						}
					]
				},
				{
					"comment": "double quoted here-strings",
					"begin": "\\G@[\"\\x{201C}-\\x{201E}]",
					"beginCaptures": {
						"0": {
							"name": "string.quoted.double.heredoc.powershell punctuation.definition.heredoc.begin.powershell"
						}
					},
					"end": "^([\"\\x{201C}-\\x{201E}]@)|\\G((?:\\s*\\S+)+)(?:(?!\\n)\\s)*$",
					"endCaptures": {
						"1": {
							"name": "string.quoted.double.heredoc.powershell punctuation.definition.heredoc.end.powershell"
						},
						"2": {
							"patterns": [
								{
									"match": "\\S+",
									"name": "invalid.source.powershell"
								}
							]
						}
					},
					"contentName": "string.quoted.double.heredoc.powershell",
					"patterns": [
						{
							"include": "#variableNoProperty"
						},
						{
							"include": "#doubleQuotedHereStringEscapes"
						},
						{
							"include": "#substatementNoProperty"
						}
					]
				},
				{
					"comment": "single quoted here-strings",
					"begin": "\\G@['\\x{2018}-\\x{201B}]",
					"beginCaptures": {
						"0": {
							"name": "string.quoted.single.heredoc.powershell punctuation.definition.heredoc.begin.powershell"
						}
					},
					"end": "^(['\\x{2018}-\\x{201B}]@)|\\G((?:\\s*\\S+)+)(?:(?!\\n)\\s)*$",
					"endCaptures": {
						"1": {
							"name": "string.quoted.single.heredoc.powershell punctuation.definition.heredoc.end.powershell"
						},
						"2": {
							"patterns": [
								{
									"match": "\\S+",
									"name": "invalid.source.powershell"
								}
							]
						}
					},
					"contentName": "string.quoted.single.heredoc.powershell"
				},
				{
					"comment": "double quoted strings",
					"begin": "\\G(?:[\"\\x{201C}-\\x{201E}])",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.powershell"
						}
					},
					"end": "(?:[\"\\x{201C}-\\x{201E}])",
					"applyEndPatternLast": true,
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.powershell"
						}
					},
					"name": "string.quoted.double.powershell",
					"patterns": [
						{
							"include": "#variableNoProperty"
						},
						{
							"include": "#doubleQuotedStringEscapes"
						},
						{
							"include": "#substatementNoProperty"
						}
					]
				},
				{
					"begin": "(?=\\.(?!\\.)|::|\\[)",
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#accessors"
						}
					]
				}
			]
		},
		"functionName": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#argumentModeEscapes"
				},
				{
					"begin": "['\\x{2018}-\\x{201B}]",
					"end": "['\\x{2018}-\\x{201B}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"match": "['\\x{2018}-\\x{201B}]{2}",
							"name": "constant.character.escape.powershell"
						}
					]
				},
				{
					"begin": "[\"\\x{201C}-\\x{201E}]",
					"end": "[\"\\x{201C}-\\x{201E}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#doubleQuotedStringEscapes"
						},
						{
							"begin": "\\$\\(",
							"end": "\\)",
							"patterns": [
								{
									"include": "#functionName"
								}
							]
						}
					]
				},
				{
					"begin": "\\$\\(",
					"end": "\\)",
					"patterns": [
						{
							"include": "#functionName"
						}
					]
				},
				{
					"begin": "\\$\\{",
					"end": "}",
					"patterns": [
						{
							"match": "\\$"
						},
						{
							"include": "#functionName"
						}
					]
				}
			]
		},
		"unquotedStrings_text": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#argumentModeEscapes"
				},
				{
					"include": "#variableNoProperty"
				},
				{
					"include": "#quotedStrings_Members"
				},
				{
					"include": "#substatementNoProperty"
				}
			]
		},
		"unquotedStrings_text_interpolatedString": {
			"comment": "!!!!!!!!!!!!!!!!!!WIP!!!",
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "constant.character.escape.powershell"
				},
				{
					"include": "#argumentModeEscapes"
				},
				{
					"begin": "['\\x{2018}-\\x{201B}]",
					"end": "['\\x{2018}-\\x{201B}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"match": "['\\x{2018}-\\x{201B}]{2}",
							"name": "constant.character.escape.powershell"
						}
					]
				},
				{
					"begin": "[\"\\x{201C}-\\x{201E}]",
					"end": "[\"\\x{201C}-\\x{201E}]",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#doubleQuotedStringEscapes"
						},
						{
							"begin": "\\$\\(",
							"end": "\\)",
							"patterns": [
								{
									"include": "#unquotedStrings_text"
								}
							]
						}
					]
				},
				{
					"begin": "\\$\\(",
					"end": "\\)",
					"patterns": [
						{
							"include": "#unquotedStrings_text"
						}
					]
				}
			]
		},
		"terminators": {
			"patterns": [
				{
					"comment": "`;` resume's in statement mode.",
					"match": ";",
					"name": "punctuation.terminator.statement.powershell"
				},
				{
					"comment": "`,` just continues current mode",
					"match": ",",
					"name": "punctuation.separator.powershell"
				}
			]
		},
		"operators_postUnary": {
			"comment": "expression mode operators that follow operands (cannot have implicit operand on the left).",
			"patterns": [
				{
					"match": "(\\+\\+)|([\\x{2013}-\\x{2015}-]{2})",
					"captures": {
						"1": {
							"name": "keyword.operator.arithmetic.postfix.unary.increment.powershell"
						},
						"2": {
							"name": "keyword.operator.arithmetic.postfix.unary.decrement.powershell"
						}
					}
				},
				{
					"comment": "the range operator is only available after an operand (but is a binary operator)",
					"begin": "(?<!^)\\s*(\\.\\.)",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.range.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				}
			]
		},
		"operators_preUnary": {
			"comment": "expression mode unary operators that precede operands.",
			"patterns": [
				{
					"begin": "(\\+\\+)|([\\x{2013}-\\x{2015}-]{2})",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.arithmetic.prefix.unary.increment.powershell"
						},
						"2": {
							"name": "keyword.operator.arithmetic.prefix.unary.decrement.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"reserve": "#numericConstant"
				},
				{
					"begin": "(?:(?=[\\x{2013}-\\x{2015}-])(?i:(.not)|(.bnot)|(.))|(!))(?!\\p{L})|(\\+)",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.logical.unary.not.powershell"
						},
						"2": {
							"name": "keyword.operator.bitwise.unary.bnot.powershell"
						},
						"3": {
							"name": "keyword.operator.arithmetic.unary.negate.powershell"
						},
						"4": {
							"name": "keyword.operator.logical.unary.not.powershell"
						},
						"5": {
							"name": "keyword.operator.arithmetic.unary.positive.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				}
			]
		},
		"operators": {
			"patterns": [
				{
					"include": "#operators_postUnary"
				},
				{
					"begin": "(?=[\\x{2013}-\\x{2015}-])(?i:(.is(?:not)?)|(.as))(?!\\p{L})",
					"beginCaptures": {
						"1": {
							"name": "keyword.operator.comparison.type.powershell"
						},
						"2": {
							"name": "keyword.operator.type-cast.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:[ic]?(?:eq|ne|[gl][te]|(?:not)?(?:like|match|contains|in))))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.comparison.$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:join|[ic]?(?:split|replace)))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.string-$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:and|or|xor))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.logical.$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-]((?i:band|bor|bxor|shl|shr))(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.bitwise.$1.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[\\x{2013}-\\x{2015}-](?i:f)(?!\\p{L})",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.string-format.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"begin": "[+%*/\\x{2013}-\\x{2015}-]?=",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.assignment.powershell"
						}
					},
					"end": "$(?=\\n)(?!\\G)|(?=[,;&)}\\]])",
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"include": "$self"
						}
					]
				},
				{
					"begin": "[+%*/]|[\\x{2013}-\\x{2015}-](?![\\p{L}\\x{2013}-\\x{2015}-])",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.arithmetic.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToToken"
						}
					]
				},
				{
					"comment": "included last only because preunary also includes the negate `!` and `-b?not` operators, but we didn't want the `-` negate operator replacing `-` subtract.",
					"include": "#operators_preUnary"
				}
			]
		},
		"notCode": {
			"patterns": [
				{
					"match": "`(?!\\n)\\s",
					"name": "invalid.character.escape.powershell"
				},
				{
					"include": "#commentBlock"
				},
				{
					"include": "#commentLine"
				},
				{
					"comment": "when nothing else matches in usual tokenizing, consume it to prevent other patterns from striking in the middle of what might be a command name.",
					"begin": "(?=[^\\[\\s{(,;&|)}])",
					"end": "(?=[\\s{(,;&|)}])",
					"contentName": "invalid.source.powershell",
					"patterns": [
						{
							"include": "#unquotedStrings_text"
						}
					]
				}
			]
		},
		"redirection": {
			"patterns": [
				{
					"comment": "`&` resume's in statement mode",
					"begin": "&(?!&)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.separator.job.powershell"
						}
					},
					"end": "$(?=\\n)(?!\\G)|(?=[;)}\\]])",
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"include": "$self"
						}
					]
				},
				{
					"comment": "`|` resume's in command mode",
					"begin": "\\|(?!\\|)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.separator.powershell"
						}
					},
					"end": "$(?=\\n)(?!\\G)|(?=[;&)}\\]])",
					"patterns": [
						{
							"include": "#advanceToToken"
						},
						{
							"include": "#command_mode"
						}
					]
				},
				{
					"match": "<(?!#)",
					"name": "invalid.reserved.redirection.powershell"
				},
				{
					"match": "[2-6*]>&1",
					"name": "keyword.operator.redirection.to-stdout.powershell"
				},
				{
					"begin": "[1-6*]?>>?",
					"beginCaptures": {
						"0": {
							"name": "keyword.operator.redirection.powershell"
						}
					},
					"end": "(?=.|$)",
					"applyEndPatternLast": true,
					"patterns": [
						{
							"include": "#advanceToArgument"
						},
						{
							"begin": "(?<=[\\s>]|\\G|^)(?![\\s#;&|)}]|<#|$|`\\s)",
							"end": "(?!\\G)",
							"name": "meta.argument.redirect-file.powershell",
							"patterns": [
								{
									"comment": "`,`, `<` and `>` not permitted here",
									"match": "[,<>]",
									"name": "invalid.source.powershell"
								},
								{
									"include": "#argument"
								}
							]
						}
					]
				}
			]
		}
	}
}