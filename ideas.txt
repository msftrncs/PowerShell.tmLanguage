IF statement logic


FOR         (commands;)     {statements}

WHILE       (condition)     {statements}


IF          (condition)     {statements}

    ELSEIF  (condition)     {statements}   ...

    ELSE                    {statements}


DO
                            {statements}
    WHILE/UNTIL (condition)

TRY                         {statements}
    CATCH       [exception],{statements}    ...
    FINALLY                 {statements}



after detecting the keyword, 
    BEGIN with "\G" (and not any invalid chars)
    END with "\(" (or any invalid chars, maybe just any "\S")
    PATTERNS 
        available switches
        notCode

This will these items to just immediately after the keyword.


begin when a `(` is coming
end with any character not processed or an end of line
    begin with the `(` (with \G)
    end when the `)` is coming
        process inner condition in command_mode
    begin with the `)`
    end with any character not processed or an end of line
        advancedToToken
        begin when a `{` is coming
        end with any character not processed or an end of line
            begin with the `{` (with \G)
            end with the `}`
                process inner condition in $self
            begin when just past `}` AND NOT followed by `}`
            end with any character not processed or an end of line
                advancedToToken
                begin with `elseif`
                end with any character not processed or an end of line
                    advancedToToken
                    begin when a `(` is coming
                    end with any character not processed or an end of line
                        begin with the `(` (with \G)
                        end when the `)` is coming
                            process inner condition in command_mode
                        begin with the `)`
                        end with any character not processed or an end of line
                            advancedToToken
                            begin when a `{` is coming
                            end with any character not processed or an end of line
                                begin with the `{` (with \G)
                                end when the `}` is coming
                                    process inner condition in $self
            begin with `else`
            end with any character not processed or an end of line
                advancedToToken
                begin when a `(` is coming
                end with any character not processed or an end of line
                    begin with the `(` (with \G)
                    end when the `)` is coming
                        process inner condition in command_mode
                    begin with the `)`
                    end with any character not processed or an end of line
                        advancedToToken
                        begin when a `{` is coming
                        end any character not processed or an end of line
                            begin with the `{` (with \G)
                            end with `}`
                                process inner condition in $self

ESLEIF needs to loop, be recursive, on its own
ELSE needs to be the last chance to match, this might beed to be done in the root of IF.
Need to not get caught on nested IF's that close together, need to make sure to completely close out of one statement, so the end of the next one can be detected!

Its possible that either an expression is ending `)` or a scriptblock is ending `}`.
Its also possible a new expression `(` or a new scriptblock `{` may follow.
Recursive to $SELF is the only way to prevent refire of `(` or `{`

This mean ELSE and ELSEIF must both be found recursively, so the syntax always moves forward until there is a clearly delimiting character (in this case, a line end)

Remember, use begin when something is next, end when !\G to return immediately after the end.

   <---------------------> repeatable
IF(cond){statements}ELSEIF(cond){statments} 
                    ^^^^^^ Optional, but terminates repeating without it
                    ELSE{statements} <- alternate ending

AdvanceToToken
Begin when `(` is next
End with any character not processed or end of line
    include common `(cond){statements}ELSEIF` patterns
    Begin with `ELSE`



complex argument scoping.
arguments that start with a variable reference need to process first variable, if it posses a member or index reference, the argument ends at the end of the reference.  If there is no reference, then the argument is an unquoted expandable string, for which further embedded variables cannot reference members.
arguments that start with a `.$` actually represent two arguments. `.` becomes its own argument.
All other unquoted arguments are expandable strings.  Embedded variables cannot reference variables.
An argument that starts with a substatement, the substatement is its own argument.
 
 Redesign Expression Mode

 Expression mode should be a multi-tier mode.  Root tier should look for prefix operators before arguments
    finding a prefix operator then searches for continued prefix operators, whhich is an even smaller list of operators, or an operand.
    finding an operand then searches for postfix operators, and then general operators
        finding a general operator starts back over with the root.

[prefix [cont prefix]] operand [postfix] [operator [...]]

